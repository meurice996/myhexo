<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="参考视频是广东海洋大学的课程录像，参考书目为冈萨雷斯等著，阮秋琦等译的《数字图像处理》（第四版）。\n">
<title>数字图像处理</title>

<link rel='canonical' href='https://demo.stack.jimmycai.com/p/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="数字图像处理">
<meta property='og:description' content="参考视频是广东海洋大学的课程录像，参考书目为冈萨雷斯等著，阮秋琦等译的《数字图像处理》（第四版）。\n">
<meta property='og:url' content='https://demo.stack.jimmycai.com/p/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/'>
<meta property='og:site_name' content='zn.yan'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2022-02-05T11:23:00&#43;00:00'/><meta property='article:modified_time' content='2022-02-05T11:23:00&#43;00:00'/>
<meta name="twitter:title" content="数字图像处理">
<meta name="twitter:description" content="参考视频是广东海洋大学的课程录像，参考书目为冈萨雷斯等著，阮秋琦等译的《数字图像处理》（第四版）。\n">
    <link rel="shortcut icon" href="/favicon.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu2195195251581500850.jpg" width="300"
                            height="301" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">zn.yan</a></h1>
            <h2 class="site-description">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='mailto:yanzhn@outlook.com'
                        target="_blank"
                        title="Email"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"> <path d="M3 7a2 2 0 0 1 2 -2h14a2 2 0 0 1 2 2v10a2 2 0 0 1 -2 2h-14a2 2 0 0 1 -2 -2v-10z"></path> <path d="M3 7l9 6l9 -6"></path> </svg> 
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/znyan'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://www.instagram.com/yanzhongnuo/'
                        target="_blank"
                        title="Instagram"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"> <path d="M4 4m0 4a4 4 0 0 1 4 -4h8a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-8a4 4 0 0 1 -4 -4z"></path> <path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path> <path d="M16.5 7.5l0 .01"></path> </svg> 
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='#ZgotmplZ'
                        target="_blank"
                        title="WeChat"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"> <path d="M16.5 10c3.038 0 5.5 2.015 5.5 4.5c0 1.397 -.778 2.645 -2 3.47l0 2.03l-1.964 -1.178a6.649 6.649 0 0 1 -1.536 .178c-3.038 0 -5.5 -2.015 -5.5 -4.5s2.462 -4.5 5.5 -4.5z"></path> <path d="M11.197 15.698c-.69 .196 -1.43 .302 -2.197 .302a8.008 8.008 0 0 1 -2.612 -.432l-2.388 1.432v-2.801c-1.237 -1.082 -2 -2.564 -2 -4.199c0 -3.314 3.134 -6 7 -6c3.782 0 6.863 2.57 7 5.785l0 .233"></path> <path d="M10 8h.01"></path> <path d="M7 8h.01"></path> <path d="M15 14h.01"></path> <path d="M18 14h.01"></path> </svg> 
                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/gallery/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"> <path d="M15 8h.01"></path> <path d="M3 6a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v12a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3v-12z"></path> <path d="M3 16l5 -5c.928 -.893 2.072 -.893 3 0l5 5"></path> <path d="M14 14l1 -1c.928 -.893 2.072 -.893 3 0l3 3"></path> </svg> 
                
                <span>Gallery</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">Table of contents</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#概述">概述</a>
      <ol>
        <li><a href="#空域的概念">空域的概念</a></li>
        <li><a href="#空域增强的模型">空域增强的模型</a></li>
        <li><a href="#分类">分类</a>
          <ol>
            <li><a href="#基于像素的空域增强">基于像素的空域增强</a></li>
            <li><a href="#基于模板的空域增强">基于模板的空域增强</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#图像间运算">图像间运算</a>
      <ol>
        <li><a href="#算数运算">算数运算</a></li>
        <li><a href="#应用">应用</a></li>
      </ol>
    </li>
    <li><a href="#直接灰度映射">直接灰度映射</a>
      <ol>
        <li><a href="#原理">原理</a></li>
        <li><a href="#典型灰度映射">典型灰度映射</a>
          <ol>
            <li><a href="#图像求反">图像求反</a></li>
            <li><a href="#对比度增强">对比度增强</a></li>
            <li><a href="#分段线性增强">分段线性增强</a></li>
            <li><a href="#对数变换">对数变换</a></li>
            <li><a href="#幂律伽马变换">幂律（伽马）变换</a></li>
            <li><a href="#灰度切割灰度级分层">灰度切割（灰度级分层）</a></li>
            <li><a href="#阈值化处理二值化处理灰度切割的特例">阈值化处理（二值化处理，灰度切割的特例）</a></li>
            <li><a href="#位图切割">位图切割</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#直方图修正直方图均衡化">直方图修正——直方图均衡化</a>
      <ol>
        <li><a href="#直方图和累计直方图">直方图和累计直方图</a>
          <ol>
            <li><a href="#直方图">直方图</a></li>
            <li><a href="#归一化直方图">归一化直方图</a></li>
            <li><a href="#累计直方图">累计直方图</a></li>
            <li><a href="#归一化累计直方图">归一化累计直方图</a></li>
          </ol>
        </li>
        <li><a href="#直方图均衡化原理">直方图均衡化原理</a></li>
      </ol>
    </li>
    <li><a href="#空间滤波机理">空间滤波机理</a></li>
    <li><a href="#线性滤波">线性滤波</a>
      <ol>
        <li><a href="#技术分类和实现原理">技术分类和实现原理</a>
          <ol>
            <li><a href="#技术分类">技术分类</a></li>
            <li><a href="#实现原理模板卷积">实现原理（模板卷积）</a></li>
          </ol>
        </li>
        <li><a href="#线性平滑滤波器">线性平滑滤波器</a>
          <ol>
            <li><a href="#邻域平均">邻域平均</a></li>
            <li><a href="#加权平均">加权平均</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#非线性滤波">非线性滤波</a>
      <ol>
        <li><a href="#非线性平滑滤波器">非线性平滑滤波器</a>
          <ol>
            <li><a href="#中值滤波器">中值滤波器</a></li>
            <li><a href="#百分比滤波器">百分比滤波器</a></li>
            <li><a href="#中点滤波器">中点滤波器</a></li>
          </ol>
        </li>
        <li><a href="#非线性锐化滤波器">非线性锐化滤波器</a>
          <ol>
            <li><a href="#数字图像微分">数字图像微分</a></li>
            <li><a href="#基于一阶微分的锐化滤波器梯度算子">基于一阶微分的锐化滤波器——梯度算子</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <ol>
    <li>
      <ol>
        <li>
          <ol>
            <li></li>
            <li><a href="#基于二阶微分的锐化滤波器拉普拉斯算子">基于二阶微分的锐化滤波器——拉普拉斯算子</a></li>
            <li><a href="#混合空间增强法">混合空间增强法</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#傅里叶变换及其反变换">傅里叶变换及其反变换</a>
      <ol>
        <li><a href="#一维连续傅里叶变换及反变换">一维连续傅里叶变换及反变换</a></li>
        <li><a href="#二维连续傅里叶变换及反变换">二维连续傅里叶变换及反变换</a></li>
        <li><a href="#一维dft及idft">一维DFT及IDFT</a>
          <ol>
            <li><a href="#傅里叶变换fu的极坐标表示">傅里叶变换$F(u)$的极坐标表示</a></li>
          </ol>
        </li>
        <li><a href="#二维dft及idft">二维DFT及IDFT</a>
          <ol>
            <li><a href="#二维dft的极坐标表示">二维DFT的极坐标表示</a></li>
          </ol>
        </li>
        <li><a href="#关于频谱fuv">关于频谱$|F(u,v)|$</a></li>
      </ol>
    </li>
    <li><a href="#傅里叶变换的性质">傅里叶变换的性质</a>
      <ol>
        <li><a href="#平移">平移</a></li>
        <li><a href="#可分离性">可分离性</a></li>
        <li><a href="#平均值">平均值</a></li>
      </ol>
    </li>
    <li><a href="#快速傅里叶变换fft">快速傅里叶变换（FFT）</a></li>
  </ol>

  <ol>
    <li><a href="#频率域滤波基础">频率域滤波基础</a>
      <ol>
        <li><a href="#傅里叶变换的频率分量与图像空间特征">傅里叶变换的频率分量与图像空间特征</a></li>
        <li><a href="#频率域滤波的基本步骤">频率域滤波的基本步骤</a></li>
        <li><a href="#频域滤波器如何作用于图像">频域滤波器如何作用于图像</a>
          <ol>
            <li><a href="#低通滤波器">低通滤波器</a></li>
            <li><a href="#高通滤波器">高通滤波器</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#频率域低通平滑滤波器">频率域低通（平滑）滤波器</a>
      <ol>
        <li><a href="#理想低通滤波器ilpf">理想低通滤波器（ILPF）</a></li>
        <li><a href="#巴特沃斯低通滤波器blpf">巴特沃斯低通滤波器（BLPF）</a></li>
        <li><a href="#高斯低通滤波器glpf">高斯低通滤波器（GLPF）</a></li>
        <li><a href="#应用实例">应用实例</a></li>
      </ol>
    </li>
    <li><a href="#频率域高通锐化滤波器">频率域高通（锐化）滤波器</a>
      <ol>
        <li><a href="#理想高通滤波器ihpf">理想高通滤波器（IHPF）</a></li>
        <li><a href="#巴特沃斯高通滤波器bhpf">巴特沃斯高通滤波器（BHPF）</a></li>
        <li><a href="#高斯高通滤波器ghpf">高斯高通滤波器（GHPF）</a></li>
        <li><a href="#高通滤波器与低通滤波器的关系">高通滤波器与低通滤波器的关系</a></li>
        <li><a href="#高频提升和高频加强">高频提升和高频加强</a>
          <ol>
            <li><a href="#高频提升滤波">高频提升滤波</a></li>
            <li><a href="#高频加强滤波">高频加强滤波</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#图像退化复原过程的模型">图像退化/复原过程的模型</a>
      <ol>
        <li><a href="#图像退化与图像复原">图像退化与图像复原</a></li>
        <li><a href="#图像退化复原模型">图像退化/复原模型</a></li>
      </ol>
    </li>
    <li><a href="#噪声模型">噪声模型</a>
      <ol>
        <li><a href="#均匀噪声">均匀噪声</a></li>
        <li><a href="#指数噪声">指数噪声</a></li>
        <li><a href="#高斯噪声">高斯噪声</a></li>
        <li><a href="#瑞利噪声">瑞利噪声</a></li>
        <li><a href="#伽马噪声">伽马噪声</a></li>
        <li><a href="#脉冲噪声">脉冲噪声</a></li>
      </ol>
    </li>
    <li><a href="#空间域滤波复原">空间域滤波复原</a>
      <ol>
        <li><a href="#自适应滤波器">自适应滤波器</a></li>
      </ol>
    </li>
    <li><a href="#退化函数的估计">退化函数的估计</a>
      <ol>
        <li><a href="#图像观察估计法">图像观察估计法</a></li>
        <li><a href="#试验估计法">试验估计法</a></li>
        <li><a href="#模型估计法">模型估计法</a>
          <ol>
            <li><a href="#散焦模糊disk-blur">散焦模糊（Disk Blur）</a></li>
            <li><a href="#运动模糊motion-deblur">运动模糊（Motion Deblur）</a></li>
            <li><a href="#大气湍流模糊">大气湍流模糊</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#图像复原方法逆滤波">图像复原方法——逆滤波</a></li>
    <li><a href="#图像复原方法维纳滤波">图像复原方法——维纳滤波</a></li>
  </ol>

  <ol>
    <li><a href="#概述-1">概述</a></li>
    <li><a href="#集合论基础">集合论基础</a>
      <ol>
        <li><a href="#并交补差">并、交、补、差</a></li>
        <li><a href="#反射与平移">反射与平移</a>
          <ol>
            <li><a href="#反射">反射</a></li>
            <li><a href="#平移-1">平移</a></li>
          </ol>
        </li>
        <li><a href="#二值图像的逻辑运算">二值图像的逻辑运算</a></li>
      </ol>
    </li>
    <li><a href="#二值图像形态学处理">二值图像形态学处理</a></li>
    <li><a href="#膨胀和腐蚀">膨胀和腐蚀</a>
      <ol>
        <li><a href="#膨胀">膨胀</a></li>
        <li><a href="#腐蚀">腐蚀</a></li>
      </ol>
    </li>
    <li><a href="#开启和闭合">开启和闭合</a>
      <ol>
        <li><a href="#开启">开启</a></li>
        <li><a href="#闭合">闭合</a></li>
        <li><a href="#实例matlab">实例（MATLAB）</a>
          <ol>
            <li><a href="#实例1">实例1</a></li>
            <li><a href="#实例2去除指纹图像上的杂散点">实例2（去除指纹图像上的杂散点）</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#形态学的主要应用">形态学的主要应用</a>
      <ol>
        <li><a href="#边界提取">边界提取</a></li>
        <li><a href="#孔洞填充">孔洞填充</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#图像缩放的变换公式">图像缩放的变换公式</a></li>
    <li><a href="#图像的缩小">图像的缩小</a>
      <ol>
        <li><a href="#图像缩小的实现方法">图像缩小的实现方法</a></li>
      </ol>
    </li>
    <li><a href="#图像的放大">图像的放大</a>
      <ol>
        <li><a href="#图像放大的实现方法">图像放大的实现方法</a></li>
        <li><a href="#最近邻插值">最近邻插值</a></li>
        <li><a href="#双线性插值">双线性插值</a></li>
        <li><a href="#双三次插值">双三次插值</a></li>
      </ol>
    </li>
  </ol>

  <ol>
    <li><a href="#概述-2">概述</a>
      <ol>
        <li><a href="#图像的边缘模型">图像的边缘模型</a></li>
        <li><a href="#无噪图像的导数与边缘的关系">无噪图像的导数与边缘的关系</a></li>
      </ol>
    </li>
    <li><a href="#基本的边缘检测技术">基本的边缘检测技术</a>
      <ol>
        <li><a href="#图像梯度及其性质">图像梯度及其性质</a></li>
        <li><a href="#梯度算子直接差分算子">梯度算子——直接差分算子</a></li>
        <li><a href="#梯度算子roberts算子">梯度算子——Roberts算子</a></li>
        <li><a href="#梯度算子prewitt算子">梯度算子——Prewitt算子</a></li>
        <li><a href="#梯度算子sobel算子">梯度算子——Sobel算子</a></li>
        <li><a href="#梯度算子用于检测对角边缘的prewittsobel算子">梯度算子——用于检测对角边缘的Prewitt、Sobel算子</a></li>
      </ol>
    </li>
    <li><a href="#先进的边缘检测技术">先进的边缘检测技术</a>
      <ol>
        <li><a href="#marr-hildreth马尔-希尔德雷斯边缘检测器">Marr-Hildreth（马尔-希尔德雷斯）边缘检测器</a>
          <ol>
            <li><a href="#基于二阶微分导数的边缘检测技术拉普拉斯算子">基于二阶微分（导数）的边缘检测技术——拉普拉斯算子</a></li>
            <li><a href="#marr-hildreth边缘检测器的提出及实现">Marr-Hildreth边缘检测器的提出及实现</a></li>
            <li><a href="#寻找零交叉的方法">寻找零交叉的方法</a></li>
          </ol>
        </li>
        <li><a href="#canny坎尼边缘检测器">Canny（坎尼）边缘检测器</a>
          <ol>
            <li><a href="#非极大值抑制non-maxima-suppression-nms">非极大值抑制（Non-Maxima Suppression, NMS）</a></li>
            <li><a href="#对nms结果使用双阈值检测边缘">对NMS结果使用双阈值检测边缘</a></li>
            <li><a href="#对双阈值边缘检测结果进行边缘连接">对双阈值边缘检测结果进行边缘连接</a></li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" >
                图像处理
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">数字图像处理</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Feb 05, 2022</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>参考视频是广东海洋大学的课程录像，参考书目为冈萨雷斯等著，阮秋琦等译的《数字图像处理》（第四版）。</p>
<h1 id="图像的空域增强技术">图像的空域增强技术
</h1><h2 id="概述">概述
</h2><h3 id="空域的概念">空域的概念
</h3><ul>
<li><strong>空域</strong>：像素组成的空间。</li>
<li><strong>空域增强技术</strong>：直接作用于图像像素的增强技术。</li>
</ul>
$$
像素的空间坐标(x,y) \rightarrow 像素的灰度值f(x,y)
$$<h3 id="空域增强的模型">空域增强的模型
</h3>$$
g(x,y)=E_H[f(x,y)]
$$<h3 id="分类">分类
</h3><h4 id="基于像素的空域增强">基于像素的空域增强
</h4><p>$E_H$定义在每个<strong>像素</strong>$(x,y)$上。</p>
<ul>
<li>
<p>像素点操作：$g(x,y)=P_{xy}[f(x,y)]$</p>
</li>
<li>
<p>几何操作：$(x&rsquo;,y&rsquo;)=M(x,y)$</p>
</li>
</ul>
<h4 id="基于模板的空域增强">基于模板的空域增强
</h4>$$
t=E_H[s,n(s)]
$$<h2 id="图像间运算">图像间运算
</h2><h3 id="算数运算">算数运算
</h3><p>两幅图像对应位置像素$p、q$：$p+q、p-q、p\times q、p\div q$</p>
<h3 id="应用">应用
</h3><ul>
<li>
<p>图像去噪</p>
$$
  \begin{aligned}
  g(x,y)&=f(x,y)+e(x,y) \\
  \overline{g}(x,y)&=\frac{1}{M} \sum_{i=1}^{M}g_i(x,y)
  \end{aligned}
  $$</li>
<li>
<p>医学图像的数字减影</p>
</li>
<li>
<p>图像局部显示</p>
<p>二值模板图像与原图像做<strong>乘法</strong>，进行图像的局部显示。</p>
</li>
</ul>
<h2 id="直接灰度映射">直接灰度映射
</h2><h3 id="原理">原理
</h3>$$
灰度值\xrightarrow{f}另一灰度值
$$<h3 id="典型灰度映射">典型灰度映射
</h3><h4 id="图像求反">图像求反
</h4>$$
t=(L-1)-s
$$<h4 id="对比度增强">对比度增强
</h4><p>基于像素的图像增强，即增强原图的各部分反差。</p>
<h4 id="分段线性增强">分段线性增强
</h4><p>拉伸感兴趣的图像细节的灰度级。</p>
<p>eg.对于$0\sim 255$的灰度取值范围，划分为$0\sim 100、101\sim 200、201\sim 255$三个取值区间，只改变其中某段进行灰度变换。</p>
$$
\large
t =
\begin{cases} 
\frac{t_1}{s_1}s,  & 0\le s \le s_1\\
\frac{t_2-t_1}{s_2-s_1}[s-s_1]+t_1, &s_1 \lt s \le s_2 \\
\frac{L-1-t_2}{L-1-s_2}[s-s_2]+t_2, &s2 \lt s \le L-1
\end{cases}
$$<p>经过<strong>斜率小于1</strong>的线性变换函数后：</p>
<ul>
<li>压缩了灰度的动态范围</li>
<li>对比度下降</li>
</ul>
<p>经过<strong>斜率大于1</strong>的线性变换函数后，反之。</p>
<h4 id="对数变换">对数变换
</h4><p>原图动态范围太大，超出某些设备所允许的动态范围，需要压缩其动态范围，即$0 \sim L&rsquo;(\gt L-1) \longrightarrow 0 \sim L-1$。</p>
$$
t=C\log(1+|s|)
$$<p>
其中$C$为尺度比例常数。</p>
<p>可以使用对数变换来扩展图像中暗像素的值，同时压缩高灰度级的值。</p>
<h4 id="幂律伽马变换">幂律（伽马）变换
</h4>$$
t=c\times s^\gamma
$$<p>其中$c$和$\gamma$为正常数。</p>
<p>对于$\gamma (\gamma \lt 1)$的幂律曲线，将较窄范围的暗色输入值映射为较宽范围的亮色输入值（<em>与对数变换类似</em>）；同时，将较宽范围的亮色输入值映射为较窄范围的输出值，$\gamma \gt$ 1的幂律变换与之效果完全相反。</p>
<p>可以采用幂律变换提升图像细节的质量。</p>
<h4 id="灰度切割灰度级分层">灰度切割（灰度级分层）
</h4><p>增强特定范围的对比度，用来突出图像中<strong>特定灰度范围</strong>的亮度。</p>
<ul>
<li>
$$
  t =
  \begin{cases} 
  t_2,  & s_1\le s \le s_2\\
  t_1,  & \text{其他}
  \end{cases}
  $$</li>
<li>
$$
  t =
  \begin{cases} 
  t_2,  & s_1\le s \le s_2\\
  s,  & \text{其他}
  \end{cases}
  $$</li>
</ul>
<h4 id="阈值化处理二值化处理灰度切割的特例">阈值化处理（二值化处理，灰度切割的特例）
</h4>$$
t =
\begin{cases} 
0,  & s\lt s_1\\
L-1,  & s\ge s_1
\end{cases}
$$<p>最终产生一个<strong>黑白图像</strong>。</p>
<h4 id="位图切割">位图切割
</h4><p>$8$比特表示的图像看作$8$个单独的$1$比特平面（位图）组成，位面0表示最低位面，位面7表示最高位面。</p>
<p>每个位面均为<strong>二值图像</strong>，位面图像中像素的灰度值等于相应有效位的取值。</p>
<p>可实现以下应用：</p>
<ul>
<li>操作特定位面增强图像</li>
<li>确定用于量化该图像的比特数的充分性</li>
<li>图像压缩</li>
</ul>
<h5 id="实现方法">实现方法
</h5><p>图像各像素的灰度值除以各有效位的权值$2^i$（$i$为有效位的序数，从$0$计数），商的整数部分为<strong>奇数</strong>，则该灰度值在相应位面中映射为1，若为<strong>偶数</strong>，则映射为$0$。（<em>可类比十进制转二进制的手算方法</em>）</p>
$$
\begin{aligned}
floor(121/2^7)=0 &\quad\Rightarrow\quad 位面\ 7\ 中取值为\ 0 \\
floor(121/2^6)=1 &\quad\Rightarrow\quad 位面\ 6\ 中取值为\ 1 \\
floor(121/2^5)=3 &\quad\Rightarrow\quad 位面\ 5\ 中取值为\ 1 \\
floor(121/2^4)=7 &\quad\Rightarrow\quad 位面\ 4\ 中取值为\ 1 \\
floor(121/2^3)=15 &\quad\Rightarrow\quad 位面\ 3\ 中取值为\ 1 \\
floor(121/2^2)=30 &\quad\Rightarrow\quad 位面\ 2\ 中取值为\ 0 \\
floor(121/2^1)=60 &\quad\Rightarrow\quad 位面\ 1\ 中取值为\ 0 \\
floor(121/2^0)=121 &\quad\Rightarrow\quad 位面\ 0\ 中取值为\ 1
\end{aligned}
$$<h5 id="matlab实现代码">MATLAB实现代码
</h5><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">im</span><span class="p">=</span><span class="n">imread</span><span class="p">(</span><span class="s">&#39;fractal_iris.bmp&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">rowcnt</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">columncnt</span><span class="p">=</span><span class="nb">size</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">);</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;源图像&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">i</span><span class="p">=</span><span class="mi">7</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">x</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">rowcnt</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">y</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">columncnt</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nb">mod</span><span class="p">(</span><span class="nb">floor</span><span class="p">(</span><span class="n">double</span><span class="p">(</span><span class="n">im</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span>^<span class="nb">i</span><span class="p">)),</span><span class="mi">2</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">				<span class="n">bitmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span>
</span></span><span class="line"><span class="cl">				<span class="n">bitmap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">end</span>
</span></span><span class="line"><span class="cl">		<span class="k">end</span>
</span></span><span class="line"><span class="cl">	<span class="k">end</span>
</span></span><span class="line"><span class="cl">	<span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="o">-</span><span class="nb">i</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span><span class="n">title</span><span class="p">(</span><span class="n">strcat</span><span class="p">(</span><span class="s">&#39;位平面&#39;</span><span class="p">,</span><span class="n">num2str</span><span class="p">(</span><span class="nb">i</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="直方图修正直方图均衡化">直方图修正——直方图均衡化
</h2><h3 id="直方图和累计直方图">直方图和累计直方图
</h3><h4 id="直方图">直方图
</h4>$$
\begin{aligned}
h(k)=n_k \quad k=0,1,\cdots,L-1
\end{aligned}
$$<p>其中，$n_k$是图像$f(x,y)$中具有灰度值$k$的像素的个数。</p>
<p>是图像的一种统计表达，反映了图像中像素的灰度值的分布情况。</p>
<p>若某图像的灰度直方图具有<strong>二峰性</strong>，则表明这个图像较亮区域和较暗区域可以较好的分离。</p>
<h4 id="归一化直方图">归一化直方图
</h4>$$
\begin{aligned}
p(s_k)&=\frac{n_k}{n} \quad s_k=\frac{k}{L-1},0\le s_k\le1
\end{aligned}
$$<p>其中，$n$为图像所有像素的数量。</p>
<h4 id="累计直方图">累计直方图
</h4>$$
H(k)=\sum_{i=0}^{k}n_i
$$<p>其中，$n_i$表示图像中灰度级等于$i$的像素点数量。</p>
<h4 id="归一化累计直方图">归一化累计直方图
</h4>$$
\begin{aligned}
P(s_k)=\sum_{i=0}^kp(s_i)
\end{aligned}
$$<h3 id="直方图均衡化原理">直方图均衡化原理
</h3><p>把图像的直方图变换为<strong>均匀分布</strong>的形式，以此增强动态范围偏小的图像的反差，从而实现<strong>对比度增强</strong>。</p>
<p>实质是选用合适的变换函数来<strong>修正图像灰度级的归一化直方图</strong>$p(s_k)$，为了能从图像中获得尽量多的信息量（图像熵尽可能大），要求$p(s_k)$为<strong>常数</strong>。</p>
<p>增强函数$E_H(s)$需要满足：</p>
<ul>
<li>$E_H(s)$为单值单增函数（<em>保持原有排列次序</em>）</li>
<li>$0\le E_H(s) \le L-1$（<em>灰度级动态范围一致</em>）</li>
</ul>
<p>反变换也应该满足上述条件。</p>
<p><strong>累积分布函数（CDF）<strong>满足以上条件：
$$
t_k=E_H(s_k)=\sum_{i=0}^{k}\frac{n_i}{n}=\sum_{i=0}^{k}p(s_i)
$$
例如一幅图像$64\times 64(n=4096)$，每个像素点用3比特表示（8个灰度级），像素点的灰度值分布如下：
$$
\begin{array}{c|cccccccc}
\text{灰度级}& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7  \\
\hline 
\text{像素数量} & 790 & 1023 & 850 & 656 & 329 & 245 & 122 & 81
\end{array}
$$
实现</strong>直方图均衡化</strong>步骤如下：</p>
<ol>
<li>
$$
   \begin{array}{c|cccccccc}
   灰度级k & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7  \\
   \hline 
   归一化灰度级s_k & \frac{0}{7} & \frac{1}{7} & \frac{2}{7} & \frac{3}{7} & \frac{4}{7} & \frac{5}{7} & \frac{6}{7} & \frac{7}{7}  \\
   \hline 
   像素数量n_k & 790 & 1023 & 850 & 656 & 329 & 245 & 122 & 81 \\
   \hline
   \textbf{归一化直方图}p(s_k) & 0.19 & 0.25 & 0.21 & 0.16 & 0.08 & 0.06 & 0.03 & 0.02 
   \end{array}
   $$</li>
<li>
$$
   \begin{array}{c|cccccccc}
   灰度级k & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7  \\
   \hline 
   归一化灰度级s_k & \frac{0}{7} & \frac{1}{7} & \frac{2}{7} & \frac{3}{7} & \frac{4}{7} & \frac{5}{7} & \frac{6}{7} & \frac{7}{7}  \\
   \hline 
   像素数量n_k & 790 & 1023 & 850 & 656 & 329 & 245 & 122 & 81 \\
   \hline
   归一化直方图p(s_k) & 0.19 & 0.25 & 0.21 & 0.16 & 0.08 & 0.06 & 0.03 & 0.02  \\
   \hline
   \textbf{归一化累积直方图}t_k & 0.19 & 0.44 & 0.65 & 0.81 & 0.89 & 0.95 & 0.98 & 1.00 
   \end{array}
   $$</li>
<li>
$$
   \begin{array}{c|cccccccc}
   灰度级k & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7  \\
   \hline 
   归一化灰度级s_k & \frac{0}{7} & \frac{1}{7} & \frac{2}{7} & \frac{3}{7} & \frac{4}{7} & \frac{5}{7} & \frac{6}{7} & \frac{7}{7}  \\
   \hline 
   像素数量n_k & 790 & 1023 & 850 & 656 & 329 & 245 & 122 & 81 \\
   \hline
   归一化直方图p(s_k) & 0.19 & 0.25 & 0.21 & 0.16 & 0.08 & 0.06 & 0.03 & 0.02  \\
   \hline
   归一化累积直方图t_k & 0.19 & 0.44 & 0.65 & 0.81 & 0.89 & 0.95 & 0.98 & 1.00 \\
   \hline
   \textbf{扩展}t_k' & 1 & 3 & 5 & 6 & 6 & 7 & 7 & 7
   \end{array}
   $$<p>
其中$t&rsquo;_k$的选取：选择最靠近的一个灰度级的值，例如$0.19$离$\frac{1}{7}$最近，则修正的灰度级为$1$，以此类推。</p>
</li>
</ol>
<h2 id="空间滤波机理">空间滤波机理
</h2><p>组成：</p>
<ul>
<li>一个<strong>邻域</strong></li>
<li>对领域内像素执行的<strong>预定义操作</strong></li>
</ul>
<p>滤波在邻域中心坐标产生一个新的像素，其值是滤波操作的结果。滤波器的中心访问图像中的每个像素后生成滤波后的图像。</p>
<p>可根据执行的操作分为<strong>线性空间滤波器</strong>和<strong>非线性空间滤波器</strong>。</p>
<h2 id="线性滤波">线性滤波
</h2><h3 id="技术分类和实现原理">技术分类和实现原理
</h3><h4 id="技术分类">技术分类
</h4><h5 id="平滑滤波">平滑滤波
</h5><p>平滑线性空间滤波器使用滤波器模板确定的领域像素的平均灰度值代替邻域中心像素的值。降低了图像灰度的“尖锐”变化。</p>
<p>应用：降低噪声、模糊处理&hellip;</p>
<p>影响：边缘模糊的负面效应</p>
<h5 id="锐化滤波">锐化滤波
</h5><p>削弱图像中灰度缓慢变化的区域，同时使图像中灰度值发生突变的区域得到增强（或不变）。（即消除图像中的低频分量，同时增强（或不影响）高频分量。）</p>
<p>效果：增强被模糊的细节或目标的边缘</p>
<p><em>与平滑滤波互逆。凸显细节，弱化背景。</em></p>
<h4 id="实现原理模板卷积">实现原理（模板卷积）
</h4>$$
\begin{aligned}
g(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^bw(s,t)f(x+s,y+t)
\end{aligned}
$$<p>
其中：</p>
<ul>
<li>$w(s,t)$为滤波器系数，滤波器中心系数$w(0,0)$对准位置为$(x,y)$的像素；</li>
<li>$m=2a+1$，$n=2b+1$，且$a$、$b$为正整数。</li>
</ul>
<p><em>使用奇数尺寸的滤波器可更简化索引且更为直观，因为其滤波器的中心落在整数值上。</em></p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>将滤波器在图像中漫游，并将滤波器中心与图像中某个像素位置重合；</li>
<li>将滤波器中的各个系数与滤波器所覆盖的各对应像素的灰度值相乘；</li>
<li>将2中的所有成绩结果进行相加，并将加法运算的结果赋给图像中对应滤波器中心位置的像素（滤波器的输出响应）。</li>
</ol>
$$
\begin{bmatrix}
{ } & {\vdots} & {\vdots} & {\vdots} & { } \\
{\cdots} & {f(x-1,y-1)} & {f(x-1,y)} & {f(x-1,y+1)} & {\cdots} \\
{\cdots} & {f(x,y-1)} & {f(x,y)} & {f(x,y+1)} & {\cdots}\\
{\cdots} & {f(x+1,y-1)} & {f(x+1,y)} & {f(x+1,y+1)} & {\cdots}\\
{ } & {\vdots} & {\vdots} & {\vdots} & { }
\end{bmatrix}
$$$$
\begin{bmatrix}
{w(-1,-1)} & {w(-1,0)} & {w(-1,1)} \\
{w(0,-1)} & {w(0,0)} & {w(0,1)} \\
{w(1,-1)} & {w(1,0)} & {w(1,1)}\\
\end{bmatrix}
$$$$
\begin{aligned}
g(x,y) &= w(-1,-1)f(x-1,y-1) &&+ w(-1,0)f(x-1,y) &&+ w(-1,1)f(x-1,y+1) \\
		&+ w(0,-1)f(x,y-1) &&+ w(0,0)f(x,y) &&+ w(0,1)f(x,y+1) \\
		&+ w(1,-1)f(x+1,y-1) &&+ w(1,0)f(x+1,y) &&+ w(1,1)f(x+1,y+1)
\end{aligned}
$$<p><em><strong>对于每一个滤波的结果，其参与运算的邻域灰度值均为原始图像对应邻域的灰度值，相当于在把结果存放在一个新的空白矩阵上，而非在原始图像上就地修改。</strong></em></p>
<h3 id="线性平滑滤波器">线性平滑滤波器
</h3><h4 id="邻域平均">邻域平均
</h4>$$
g(x,y)=\frac{1}{mn}\sum_{(x,y)\in S}f(x,y)
$$<p>其中：</p>
<ul>
<li>
<p>$S$为滤波器模板覆盖的像素邻域</p>
</li>
<li>
<p>$mn$为邻域$S$中像素点数</p>
</li>
</ul>
<p>算法简单，但会使图像产生模糊，且邻域越大，模糊越厉害。</p>
<h4 id="加权平均">加权平均
</h4><p>滤波器模板中各个位置的系数采用不同的数值：</p>
<ul>
<li>离模板中心近的像素权值大</li>
<li>离模板中心远的像素权值小</li>
<li>权值之和等于1</li>
</ul>
$$
\begin{aligned}
g(x,y)=\sum_{s=-a}^{a}\sum_{t=-b}^bw(s,t)f(x+s,y+t)
\end{aligned}
$$$$
H_1 = 
\frac{1}{9}
\begin{bmatrix}
{1} & {1} & {1} \\
{1} & {1} & {1} \\
{1} & {1} & {1} \\
\end{bmatrix}
\quad
H_2 = 
\frac{1}{10}
\begin{bmatrix}
{1} & {1} & {1} \\
{1} & {2} & {1} \\
{1} & {1} & {1} \\
\end{bmatrix}
\quad
H_3 = 
\frac{1}{16}
\begin{bmatrix}
{1} & {2} & {1} \\
{2} & {4} & {2} \\
{1} & {2} & {1} \\
\end{bmatrix}
$$<h2 id="非线性滤波">非线性滤波
</h2><h3 id="非线性平滑滤波器">非线性平滑滤波器
</h3><p><strong>统计排序滤波器</strong>的响应以滤波器所覆盖的图像区域中的所有像素的<strong>排序</strong>为基础，然后使用<strong>统计排序的结果值</strong>代替中心像素的值。其具备优秀的去噪能力，且比同尺寸的线性平滑滤波器的模糊程度明显要低。</p>
<h4 id="中值滤波器">中值滤波器
</h4><p>使用像素邻域内灰度的<strong>中值</strong>代替中心像素的值。其主要功能是拥有不同灰度的像素点看起来更接近于它的相邻点（去除孤立像素）。</p>
<p>中值滤波器对处理<strong>椒盐噪声</strong>（<em>椒噪声：灰度值较低，偏暗；盐噪声：灰度值较高，偏亮。极端情况是黑色和白色噪声</em>）非常有效，因为这种噪声以黑白点的形式叠加在图像上。</p>
<h5 id="实现步骤">实现步骤
</h5><ol>
<li>将滤波器模板（无系数）在图像中漫游，并将模板中心与图像中某个像素位置重合；</li>
<li>读取模板下各对应像素的灰度值；</li>
<li>将灰度值按从小到大（或从大到小）的次序进行排序；</li>
<li>确定排序结果的中值，将此中值赋予对应模板中心位置的像素。</li>
</ol>
<p>$$
\begin{bmatrix}
{ } &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; { } \
{\cdots} &amp; {10} &amp; {20} &amp; {20} &amp; {\cdots} \
{\cdots} &amp; {20} &amp; {15} &amp; {20} &amp; {\cdots}\
{\cdots} &amp; {20} &amp; {25} &amp; {100} &amp; {\cdots}\
{ } &amp; {\vdots} &amp; {\vdots} &amp; {\vdots} &amp; { }
\end{bmatrix}</p>
<p>\Rightarrow</p>
<p>\begin{bmatrix}
{10} &amp; {15} &amp; {20} &amp; {20} &amp; \textbf{20} &amp; {20} &amp; {20} &amp; {25} &amp; {100}
\end{bmatrix}
$$</p>
<h5 id="模板选择">模板选择
</h5><p>去噪效果与以下两个因素有关：</p>
<ul>
<li>模板形状</li>
<li>参与运算的像素数量</li>
</ul>
$$
\begin{bmatrix}
{\cdot} & {\cdot} & {\cdot} & {\cdot} & {\cdot} \\
{\cdot} & {\bullet} & {\bullet} & {\bullet} & {\cdot} \\
{\cdot} & {\bullet} & {\bullet} & {\bullet} & {\cdot} \\
{\cdot} & {\bullet} & {\bullet} & {\bullet} & {\cdot} \\
{\cdot} & {\cdot} & {\cdot} & {\cdot} & {\cdot} 
\end{bmatrix}
\quad
\begin{bmatrix}
{\cdot} & {\bullet} & {\bullet} & {\bullet} & {\cdot} \\
{\bullet} & {\bullet} & {\bullet} & {\bullet} & {\bullet}  \\
{\bullet} & {\bullet} & {\bullet} & {\bullet} & {\bullet} \\
{\bullet} & {\bullet} & {\bullet} & {\bullet} & {\bullet} \\
{\cdot} & {\bullet} & {\bullet} & {\bullet} & {\cdot} 
\end{bmatrix}
\quad
\begin{bmatrix}
{\cdot} & {\cdot} & {\bullet} & {\cdot} & {\cdot} \\
{\cdot} & {\cdot} & {\bullet} & {\cdot} & {\cdot} \\
{\bullet} & {\bullet} & {\bullet} & {\bullet} & {\bullet}\\
{\cdot} & {\cdot} & {\bullet} & {\cdot} & {\cdot} \\
{\cdot} & {\cdot} & {\bullet} & {\cdot} & {\cdot} 
\end{bmatrix}
$$<ul>
<li>对于有缓变的较长轮廓线的图像，采用方形或圆形模板为宜；</li>
<li>对于包含有尖顶角物体的图像，采用十字形模板为宜，且模板大小则以不超过图像中最小有效物体的尺寸为宜；</li>
<li>对于包含点、线、尖细节较多的图像，则不适宜采用中值滤波。</li>
</ul>
<h4 id="百分比滤波器">百分比滤波器
</h4>$$
g_{max}(x,y)=\mathop{max}\limits_{(s,t)\in N(x,y)}[f(s,t)]
$$$$
g_{min}(x,y)=\mathop{min}\limits_{(s,t)\in N(x,y)}[f(s,t)]
$$<p>
椒噪声有较低的灰度值，用最大值滤波器有较好的效果，而盐噪声反之。</p>
<p><em>最大值滤波会细化黑色目标，最小值滤波会粗化黑色目标。</em></p>
<h4 id="中点滤波器">中点滤波器
</h4>$$
g_{mid}(x,y)=\frac{1}{2}[g_{max}(x,y)+g_{min}(x,y)]
$$<p>结合了排序统计和求平均，对于高斯和均匀分布随机噪声有较好效果。</p>
<p><em>中点滤波器得到的结果图像会产生模糊。</em></p>
<h3 id="非线性锐化滤波器">非线性锐化滤波器
</h3><p>锐化处理目的是突出图像中灰度的<strong>过渡</strong>部分。</p>
<p>锐化处理可以用<strong>空间微分</strong>来完成（微分算子的响应强度与像素的突变程度成正比）。即图像微分<strong>增强</strong>边缘与其他突变（噪声、线），并<strong>削弱</strong>灰度变化缓慢的区域。</p>
<p>常用滤波器：</p>
<ul>
<li>基于一阶微分的锐化滤波器</li>
<li>基于二阶微分的锐化滤波器</li>
</ul>
<h4 id="数字图像微分">数字图像微分
</h4><ol>
<li>
<p>一阶微分</p>
<ul>
<li>在<strong>恒定灰度区域</strong>的一阶微分值<strong>为零</strong>；</li>
<li>在<strong>灰度台阶、灰度斜坡的起点处</strong>一阶微分值<strong>非零</strong>；</li>
<li><strong>沿着灰度斜坡</strong>的一阶微分值<strong>非零</strong>。</li>
</ul>
</li>
<li>
<p>二阶微分</p>
<ul>
<li>在<strong>恒定灰度区域</strong>的二阶微分值<strong>为零</strong>；</li>
<li>在<strong>灰度台阶、灰度斜坡的起点处</strong>二阶微分值<strong>非零</strong>；</li>
<li><strong>沿着灰度斜坡</strong>的二阶微分值<strong>为零</strong>。</li>
</ul>
</li>
</ol>
<p>对于一维离散函数$f(x)$，采用差分计算其微分如下：</p>
<ul>
<li>
$$
  \frac{\partial f}{\partial x}=f(x+1)-f(x)
  $$</li>
<li>
$$
  \begin{aligned}
  \frac{\partial^2 f}{\partial x^2}&=[f(x+1)-f(x)]-[f(x)-f(x-1)] \\
  &= f(x+1)+f(x-1)-2f(x)
  \end{aligned}
  $$</li>
</ul>
<p>对于二维的数字图$f(x,y)$，可以沿着两个空间轴处理偏微分。</p>
$$
\begin{bmatrix}
6 & 6 & 6 & 5 & 4 & 3 & 2 & 1 & 1 & 1 & 6 & 6 & 6 \\
恒定灰度 & & 斜坡起点 &  &  & 斜坡 &  &  &  & 台 & 阶 &  &  \\
0 & 0 & -1 & -1 & -1 & -1 & 0 & 0 & 0 & 5 & 0 & 0 & 0 \\
0 & 0 & -1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & -5 & 0 & 0
\end{bmatrix}
$$<h4 id="基于一阶微分的锐化滤波器梯度算子">基于一阶微分的锐化滤波器——梯度算子
</h4><p>基于一阶微分的锐化滤波常用<strong>梯度幅值</strong>来实现。</p>
<h1 id="endbmatrixt">对于图像$f$，在任意坐标$(x.y)$上的<strong>梯度</strong>$\nabla f$定义为<strong>二维列向量</strong>：
$$
\nabla f=
\begin{bmatrix}
Gx &amp; Gy
\end{bmatrix}^T
</h1>$$
梯度的**幅值**$|\nabla f|$：
$$$$
实际应用中，一般把梯度的幅值称为梯度，并采用绝对值近似求梯度幅值：
$$<p>
|\nabla f|=|G_x|+|G_y|=|\frac{\partial f}{\partial x}| + |\frac{\partial f}{\partial y}|
$$</p>
<h5 id="梯度一阶微分的近似计算方法滤波模板">梯度（一阶微分）的近似计算方法（滤波模板）:
</h5><h6 id="直接差分">直接差分
</h6>$$
   \begin{aligned}
   G_x=f(x+1,y)-f(x,y) \\
   G_y=f(x,y+1)-f(x,y)
   \end{aligned}
$$$$
   垂直方向
   \begin{bmatrix}
   \underline{-1} & 0 \\
   1 & 0 
   \end{bmatrix}
   \quad
   水平方向
   \begin{bmatrix}
   \underline{-1}& 1 \\
   0 & 0 
   \end{bmatrix}
$$<h6 id="交叉差分">交叉差分
</h6>$$
   \begin{aligned}
   G_x=f(x+1,y+1)-f(x,y) \\
   G_y=f(x+1,y)-f(x,y+1)
   \end{aligned}
$$$$
   垂直方向
   \begin{bmatrix}
   \underline{-1} & 0 \\
   0 & 1 
   \end{bmatrix}
   \quad
   水平方向
   \begin{bmatrix}
   \underline{0} & -1 \\
   1 & 0 
   \end{bmatrix}
$$<h6 id="sobel算子">Sobel算子
</h6>$$
   \begin{aligned}
   G_x = &f(x+1,y-1)+2f(x+1,y)+f(x+1,y+1)\\
   &-f(x-1,y-1)-2f(x-1,y)-f(x-1,y+1) \\
   G_y = &f(x-1,y+1)+2f(x,y+1)+f(x+1,y+1)\\
   &- f(x-1,y-1)-2f(x,y-1)-f(x+1,y-1)
   \end{aligned}
$$$$
   垂直方向
   \begin{bmatrix}
   -1 & -2 & -1 \\
   0 & \underline{0} & 0 \\
   1 & 2 & 1 
   \end{bmatrix}
   \quad
   水平方向
   \begin{bmatrix}
   -1 & 0 & 1 \\
   -2 & \underline{0} & 2 \\
   -1 & 0 & 1 
   \end{bmatrix}
$$<p><em>下划线标出元素为滤波器模板的原点。</em></p>
<p><em>可以看出，实现<strong>平滑</strong>的滤波器系数之和为<strong>1</strong>，实现<strong>锐化</strong>的滤波器系数之和为<strong>0</strong>。</em></p>
<h5 id="应用-1">应用
</h5><p>工业检测、辅助人工检测缺陷，或更为通用的自动检测的预处理。</p>
<h4 id="基于二阶微分的锐化滤波器拉普拉斯算子">基于二阶微分的锐化滤波器——拉普拉斯算子
</h4>$$
\nabla ^2f=\frac{\partial ^2f}{\partial x^2}+\frac{\partial ^2f}{\partial y^2}
$$$$
\begin{aligned}
\frac{\partial ^2f}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y)\\
\frac{\partial ^2f}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y)
\end{aligned}
$$$$
\nabla ^2f=f(x-1,y)-2f(x,y)+f(x,y+1)+f(x,y-1)]-4f(x,y)
$$$$
(a)
\begin{bmatrix}
0 & 1 & 0 \\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix}
$$$$
(b)
\begin{bmatrix}
1 & 1 & 1 \\
1 & -8 & 1 \\
1 & 1 & 1
\end{bmatrix}
\quad
(c)
\begin{bmatrix}
0 & -1 & 0 \\
-1 & 4 & -1 \\
0 & -1 & 0
\end{bmatrix}
\quad
(d)
\begin{bmatrix}
-1 & -1 & -1 \\
-1 & 8 & -1 \\
-1 & -1 & -1
\end{bmatrix}
$$<p>$(b)$为执行离散拉普拉斯变换的扩展模板，包括了对角方向的的领域像素;$(c)、(d)$为其他两种拉普拉斯变换的实现，仅符号相反，结果等效。</p>
$$
g(x,y)=
\begin{cases}
f(x,y)-\nabla ^2f,若拉普拉斯模板中心系数为负 \\
f(x,y)+\nabla ^2f,若拉普拉斯模板中心系数为正
\end{cases}
$$<p>
将原始图像和拉普拉斯图像<strong>叠加</strong>在一起，以增强细节。</p>
<h4 id="混合空间增强法">混合空间增强法
</h4><p>若原始图像的灰度动态范围很窄并且伴随着很高的噪声，则采用单一的图像增强算法很难对其进行增强。</p>
<h1 id="傅里叶变换">傅里叶变换
</h1><h2 id="傅里叶变换及其反变换">傅里叶变换及其反变换
</h2><p>空域$\stackrel{正变换}{\longrightarrow}$其他空间$\stackrel{反变换/逆变换}{\longrightarrow}$空域。</p>
<h3 id="一维连续傅里叶变换及反变换">一维连续傅里叶变换及反变换
</h3>$$
\begin{aligned}
F(\mu)=\int_{-\infty}^{\infty}f(t)e^{-j2\pi \mu t}dt \\
f(t)=\int_{-\infty}^{\infty}F(\mu)e^{j2\pi \mu t}d\mu
\end{aligned}
$$<p>其中，$j=\sqrt{-1}$</p>
<h3 id="二维连续傅里叶变换及反变换">二维连续傅里叶变换及反变换
</h3>$$
\begin{aligned}
F(\mu,v)=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}f(t,z)e^{-j2\pi(\mu t+vz)}dtdz \\
f(t,z)=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}F(\mu,v)e^{j2\pi(\mu t+vz)}d\mu dv
\end{aligned}
$$<h3 id="一维dft及idft">一维DFT及IDFT
</h3>$$
\begin{aligned}
F_m=\frac{1}{M}\sum_{n=0}^{M-1}f_ne^{-j2\pi mn/M},\quad m=0,1,2,\cdots,M-1 \\
f_n=\sum_{m=0}^{M-1}F_me^{j2\pi mn/M},\quad n=0,1,2,\cdots,M-1
\end{aligned}
$$$$
\begin{aligned}
F(\mu)=\frac{1}{M}\sum_{x=0}^{M-1}f(x)e^{-j2\pi ux/M},\quad u=0,1,2,\cdots,M-1\\
f(x)=\sum_{u=0}^{M-1}F(u)e^{j2\pi ux/M},\quad x=0,1,2,\cdots,M-1
\end{aligned}
$$$$
e^{j\theta}=\cos\theta+j\sin\theta
$$$$
\begin{aligned}
F(u)&=\frac{1}{M}\sum_{x=0}^{M-1}f(x)e^{-j2\pi ux/M} \\
&=\frac{1}{M}\sum_{x=0}^{M-1}f(x)(\cos\frac{2\pi ux}{M}-j\sin\frac{2\pi ux}{M})
\end{aligned}
$$<h4 id="傅里叶变换fu的极坐标表示">傅里叶变换$F(u)$的极坐标表示
</h4>$$
F(u)=|F(u)|e^{-j\varphi(u)}
$$<p>其中，</p>
$$
\varphi(u)=\arctan[\frac{I(u)}{R(u)}]
$$<p>
$R(u)$和$I(u)$分别是$F(u)$的实部和虚部。</p>
$$
|F(u)|=\sqrt{R(u)^2+I(u)^2}
$$$$
P(u)=|F(u)|^2=R(u)^2+I(u)^2
$$<h3 id="二维dft及idft">二维DFT及IDFT
</h3>$$
F(u,v)=\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(ux/M+vy/N)}
$$$$
u=0,1,2,\cdots,M-1 \\
v=0,1,2,\cdots,N-1
$$$$
f(x,y)=\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}F(u,v)e^{-j2\pi(ux/M+vy/N)}
$$$$
x=0,1,2,\cdots,M-1 \\
y=0,1,2,\cdots,N-1
$$<p><em>在有些文献中，常数$1/MN$通常出现在DFT而非IDFT的前面。这时，这个常数的平方根应包含在正变换和反变换的前面，以便形成一个更为对称的变换对。只要使用一致，这种形式的任何表述就都是正确的。</em></p>
<h4 id="二维dft的极坐标表示">二维DFT的极坐标表示
</h4>$$
F(u,v)=|F(u,v)|e^{-j\varphi(u,v)}
$$<p>其中，</p>
$$
\varphi(u,v)=\arctan[\frac{I(u,v)}{R(u,v)}]
$$<p>
$R(u,v)$和$I(u,v)$分别是$F(u,v)$的实部和虚部。</p>
$$
|F(u,v)|=\sqrt{R(u,v)^2+I(u,v)^2}
$$$$
P(u,v)=|F(u,v)|^2=R(u,v)^2+I(u,v)^2
$$<h3 id="关于频谱fuv">关于频谱$|F(u,v)|$
</h3><ul>
<li>频谱描述图像中某种频率的成分数量；</li>
<li>频谱中出现的明亮线反映了原始图像的灰度级变化方向。</li>
</ul>
<h2 id="傅里叶变换的性质">傅里叶变换的性质
</h2><h3 id="平移">平移
</h3><h3 id="可分离性">可分离性
</h3>$$
\begin{aligned}
F(u,v)&=\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi (ux/M+vy/N)} \\
&= \frac{1}{M}\sum_{x=0}^{M-1}e^{-j2\pi ux/M}\frac{1}{N}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi vy/N} \\
&= \frac{1}{M}\sum_{x=0}^{M-1}e^{-j2\pi ux/M}F(x,v)
\end{aligned}
$$$$
f(x,y) \stackrel{一维行变换}{\longrightarrow} F(x,v) \stackrel{一维列变换}{\longrightarrow} F(u,v)
$$<p>
二维IDFT与上述过程类似。</p>
<h3 id="平均值">平均值
</h3>$$
F(0,0)=\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)
$$<h2 id="快速傅里叶变换fft">快速傅里叶变换（FFT）
</h2><h1 id="频率域图像增强">频率域图像增强
</h1><h2 id="频率域滤波基础">频率域滤波基础
</h2><p>在<strong>频率域</strong>研究图像增强：</p>
<ul>
<li>可以利用频率成分和图像外表之间的对应关系；（一些在空间域表述困难的增强任务，在频率域中变得非常普通。）</li>
<li>滤波在频率域更为直观，它可以解释空间域滤波的某些性质；（利用这些性质进行处理，再转换回图像空间，可以得到所需的效果。）</li>
<li>空间域和频率域中的滤波器组成了傅里叶变换对。（可以在频率域指定滤波器，并对其执行反变换，最后在空间域使用该反变换的结果作为空域滤波器。）</li>
</ul>
<h3 id="傅里叶变换的频率分量与图像空间特征">傅里叶变换的频率分量与图像空间特征
</h3><ul>
<li>
$$
  F(0,0)=\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)
  $$</li>
<li>
<p>从变换的原点移开时，低频成分对应着图像中灰度慢变化的分量（图像的平滑部分）；</p>
</li>
<li>
<p>进一步偏离原点时，较高的频率成分对应图像中变化越来越快的灰度（边缘或噪声等尖锐部分）。</p>
</li>
</ul>
<h3 id="频率域滤波的基本步骤">频率域滤波的基本步骤
</h3><ol>
<li>用$(-1)^{x+y}$乘输入图像$f(x,y)$，使其<strong>原点中心化</strong>；</li>
<li>对步骤1的结果执行<strong>DFT</strong>，得到关于中心对称的频谱$F(u,v)$；</li>
<li>生成一个<strong>实的、中心对称的频域滤波器</strong>$H(u,v)$；</li>
<li>对滤波器$H(u,v)$、频谱$F(u,v)$执行<strong>阵列相乘</strong>（对应元素逐个进行相乘),形成乘积$G(u,v)=H(u,v)F(u,v)$，其中$G(m,n)=H(m,n)F(m,n)$，且$0\le m \le M-1,0\le n \le N-1$；</li>
<li>对步骤4的结果$G(u,v)$执行<strong>反DFT</strong>，并取其结果的<strong>实部</strong>；</li>
<li>用$(-1)^{x+y}$乘步骤5的反DFT结果的实部，得到<strong>滤波结果</strong>$g(x,y)$。</li>
</ol>
<h3 id="频域滤波器如何作用于图像">频域滤波器如何作用于图像
</h3><h4 id="低通滤波器">低通滤波器
</h4><p>使频谱的<strong>低频成分通过</strong>，同时使其<strong>高频成分衰减</strong>。</p>
<ul>
<li>被低通滤波的图像比原始图像减少了尖锐的细节部分，突出了平滑过渡部分；</li>
<li>对应于空间域滤波的平滑处理，如均值滤波器。</li>
</ul>
<h4 id="高通滤波器">高通滤波器
</h4><p>使频谱的<strong>高频成分通过</strong>，同时使其<strong>低频成分衰减</strong>。</p>
<ul>
<li>被高通滤波的图像比原始图像少了灰度级的平滑过渡，突出了边缘等细节部分；</li>
<li>对应于空间域滤波的锐化处理，如梯度算子、拉普拉斯算子。</li>
</ul>
<h2 id="频率域低通平滑滤波器">频率域低通（平滑）滤波器
</h2><p>低通滤波器的作用：用于截断频谱中所有处于指定距离$D_0$之外的高频成分。</p>
<h3 id="理想低通滤波器ilpf">理想低通滤波器（ILPF）
</h3>$$
D(u,v)=\sqrt{(u-\frac{M}{2})^2+(v-\frac{N}{2})^2}
$$$$
H(u,v)=
\begin{cases}
1\quad D(u,v)\le D_0 \\
0\quad D(u,v)\gt D_0 \\
\end{cases}
$$<p>
<em>在半径为$D_0$的圆内，所有频率没有衰减地完全通过滤波器，而在此半径的圆之外的所有频率</em>完全被衰减掉。</p>
$$
P_T=\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}P(u,v)
$$$$
P(u,v)=|F(u,v)|^2=R(u,v)^2+I(u,v)^2
$$<p>
原点位于频谱中心处，半径为$D_0$的圆包含$\alpha%$的总功率，</p>
$$
\alpha=100[\sum_u\sum_vP(u,v)/P_T]
$$<ul>
<li>
<p><em>随着滤波器<strong>半径的增大</strong>，<strong>滤除的功率</strong>越来越<strong>少</strong>，导致的<strong>模糊</strong>也越来越<strong>弱</strong>。</em></p>
</li>
<li>
<p>理想低通滤波器产生<strong>模糊</strong>和<strong>振铃</strong>现象，且模糊和振铃现象<strong>反比于截断频率</strong>（即半径$D_0$）。</p>
</li>
</ul>
<h3 id="巴特沃斯低通滤波器blpf">巴特沃斯低通滤波器（BLPF）
</h3>$$
H(u,v)=\frac{1}{1+{[D(u,v)/D_0]}^{2n}}
$$<ul>
<li><strong>低阶</strong>滤波器没有明显振铃现象（滤波器在低频和高频之间平滑过渡）。<em>且1阶BLPF核即没有振铃效应又没有负值。</em></li>
</ul>
<h3 id="高斯低通滤波器glpf">高斯低通滤波器（GLPF）
</h3>$$
H(u,v)=e^{-D(u,v)^2/2\sigma ^2}
$$<p>
$\sigma$是关于频谱中心的扩展度的度量。</p>
$$
H(u,v)=e^{-D(u,v)^2/2D_0 ^2}
$$<ul>
<li>平滑效果稍差于相同截止频率的二阶BLPF；</li>
<li><strong>没有出现振铃现象</strong>，优于BLPF。</li>
</ul>
<h3 id="应用实例">应用实例
</h3><ul>
<li>用于机器识别系统识别字符的预处理；</li>
<li>减少人脸图像的皮肤细纹核小斑点；</li>
<li>消除卫星、航空图像中的不重要特征。</li>
</ul>
<h2 id="频率域高通锐化滤波器">频率域高通（锐化）滤波器
</h2><p>高通滤波器的作用：用于截断频谱中所有处于指定距离$D_0$之内的低频成分。</p>
<h3 id="理想高通滤波器ihpf">理想高通滤波器（IHPF）
</h3>$$
H(u,v)=
\begin{cases}
0\quad D(u,v)\le D_0 \\
1\quad D(u,v)\gt D_0
\end{cases}
$$<ul>
<li>振铃现象明显。</li>
</ul>
<h3 id="巴特沃斯高通滤波器bhpf">巴特沃斯高通滤波器（BHPF）
</h3>$$
H(u,v)=\frac{1}{1+{[D_0/D(u,v)]}^{2n}}
$$<ul>
<li>BHPF的结果比IHPF的结果尖锐得多，边缘失真也小得多。</li>
</ul>
<h3 id="高斯高通滤波器ghpf">高斯高通滤波器（GHPF）
</h3>$$
H(u,v)=1-e^{-D(u,v)^2/2D_0^2}
$$<ul>
<li>GHPF的结果比BHPF和IHPF的结果更尖锐，即使是对微小物体和细线条的滤波也是较清晰的。</li>
</ul>
<h3 id="高通滤波器与低通滤波器的关系">高通滤波器与低通滤波器的关系
</h3>$$
H_{HP}(u,v)=1-H_{LP}(u,v)
$$<p>其中：</p>
<p>$H_{LP}(u,v)$：低通滤波器函数；$H_{HP}(u,v)$：高通滤波器函数。</p>
<p>被低通滤波器衰减的频率成分能通过高通滤波器，反之亦然。</p>
<h3 id="高频提升和高频加强">高频提升和高频加强
</h3><p>高通滤波效果等同于用原始图像的频谱减去低通滤波的结果图像频谱。</p>
<p>图像经过高通滤波后，由于高通滤波器除去了傅里叶变换的零频率，其背景的平均强度减小到接近黑色。</p>
<p>原始图像加到滤波后的结果图像，即<strong>高频提升滤波</strong>或<strong>高频加强滤波</strong>。</p>
<h4 id="高频提升滤波">高频提升滤波
</h4><p>将原始图像按一定比例加到滤波后的结果中，以保留原始图像的背景。</p>
$$
f_{HB}(x,y)=A\times f(x,y)-f_{LP}(x,y),\quad A\ge1
$$$$
\begin{aligned}
f_{HB}(x,y)&=(A-1)\times f(x,y)+f(x,y)-f_{LP}(x,y) \\
&=(A-1)\times f(x,y)+f_{HP}(x,y)
\end{aligned}
$$$$
\begin{gather*}
f_{HB}(x,y)=(A-1)\times f(x,y)+f_{HP}(x,y) \\
\downarrow \\
F_{HB}(u,v)=(A-1)\times F(u,v)+F_{HP}(u,v) \\
\downarrow \\
F_{HB}(u,v)=(A-1)\times F(u,v)+H_{HP}(u,v)\times F(u,v) \\
\downarrow \\
F_{HB}(u,v)=[(A-1)+H_{HP}(u,v)]\times F(u,v)
\end{gather*}
$$$$
H_{HB}(u,v)=(A-1)+H_{HP}(u,v),\quad A\ge1,A=1时普通高通
$$$$
F_{HB}(u,v)=H_{HB}(u,v)\times F(u,v)
$$<h4 id="高频加强滤波">高频加强滤波
</h4><p>加强增强图像的高频成分。</p>
<p>在高通滤波器函数前乘一个常数，再增加一个偏移量以便使零频率不被滤波器滤除掉。</p>
$$
G(u,v)=H_{HP}(u,v)\times F(u,v)
$$$$
H_E(u,v)=k\times H_{HP}(u,v)+c
$$<p>
$k\ge 0$且$k\gt c$，$k$的典型值在$1.5$到$2.0$之间，$c$的典型值在$0.25$到$0.5$之间。</p>
$$
\begin{aligned}
G_E(u,v)&=H_E(u,v)\times F(u,v) \\
&= [k\times H_{HP}(u,v)+c]\times F(u,v) \\
&=k\times H_{HP}(u,v)\times F(u,v) + c\times F(u,v) \\
&=k\times G(u,v)+c\times F(u,v)
\end{aligned}
$$<h1 id="图像复原">图像复原
</h1><h2 id="图像退化复原过程的模型">图像退化/复原过程的模型
</h2><h3 id="图像退化与图像复原">图像退化与图像复原
</h3><p><strong>图像退化</strong>是指图像在形式、存储、处理和传输过程中，由于成像系统、存储设备、处理方法和传输介质的不完善，从而导致的<strong>图像质量下降</strong>。</p>
<p>引起图像退化的原因有：</p>
<ul>
<li>成像系统的散焦；</li>
<li>成像设备与物体的相对运动；</li>
<li>成像器材的固有缺陷；</li>
<li>外部干扰；</li>
<li>&hellip;&hellip;</li>
</ul>
<p><strong>图像复原</strong>（图像恢复）指的是对退化的图像进行处理，试图恢复降质的图像。</p>
<p>二者关系：</p>
<ul>
<li>图像复原可以看作是图像退化的<strong>逆过程</strong>；</li>
<li>实际情况中，退化过程往往并不知晓，这种复原称为<strong>盲目复原</strong>；</li>
<li>图像模糊的同时，噪声和干扰也会同时存在。</li>
</ul>
<h3 id="图像退化复原模型">图像退化/复原模型
</h3>$$
\begin{aligned}
f(x,y)\rightarrow 退化函数H \rightarrow &\sum \stackrel{退化图像g(x,y)}{\longrightarrow} 复原滤波器 \rightarrow \hat{f}(x,y) \\
&\uparrow 噪声n(x,y) \\ 
\end{aligned}
$$$$
g(x,y)=H[f(x,y)]+n(x,y)
$$<p><strong>图像复原</strong>：在给定$g(x,y)$和$H$的基础上得到对$f(x,y)$的某个近似，通常采用线性的、空间不变的复原技术。</p>
<p>如果退化系统（函数）$H$是<strong>线性空间不变系统</strong>：</p>
<ol>
<li>
$$
   \begin{aligned}
   & H[k_1f_1(x,y)+k_2f_2(x,y)]=k_1H[f_1(x,y)]+k_2H[f_2(x,y)] \\
   \end{aligned}
   $$<p>
齐次性：$H[kf(x,y)]=kH[f(x,y)]$</p>
<p>叠加性：$H[f_1(x,y)+f_2(x,y)]=H[f_1(x,y)]+H[f_2(x,y)]$</p>
</li>
<li>
$$
   H[f(x-a,y-b)]=g(x-a,y-b)\quad H[f(x,y)]=g(x,y)
   $$<p>
即图像中任一像素点通过退化系统时的响应只取决于该点的输入值，而与该点的位置无关。</p>
</li>
</ol>
<p>则退化图像可以表示为：</p>
$$
g(x,y)=h(x,y)*f(x,y)+n(x,y)
$$$$
G(u,v)=H(u,v)F(u,v)+N(u,v)
$$<h2 id="噪声模型">噪声模型
</h2><p>图像中的噪声是<strong>随机</strong>的，其<strong>灰度值的统计特征</strong>可以用<strong>概率密度函数</strong>（PDF）或相应的<strong>累积分布函数</strong>（CDF）进行表征。</p>
<p>对于退化图像中的噪声$n(x,y)$（<em>噪声的灰度值，非位置</em>），有多种不同的统计模型：</p>
<ul>
<li>均匀（Uniform）噪声</li>
<li>指数（Exponential）噪声</li>
<li>高斯（Gaussian）噪声</li>
<li>瑞利（Rayleigh）噪声</li>
<li>伽马（爱尔兰）噪声</li>
<li>脉冲（椒盐）噪声</li>
<li>周期噪声</li>
</ul>
<h3 id="均匀噪声">均匀噪声
</h3>$$
\Large
p(z)=
\begin{cases}
\frac{1}{b-a}\quad &a\le z\le b \\
0\quad &其他
\end{cases}
$$$$
z=a+(b-a)\times U(0,1)
$$$$
\begin{aligned}
\mu &= \frac{a+b}{2} \\
\sigma^2 &= \frac{(b-a)^2}{12}
\end{aligned}
$$<p>
实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">a</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">=</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">=</span><span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">blackIm</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noisedIm</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="n">blackIm</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="指数噪声">指数噪声
</h3>$$
\Large
p(z)=
\begin{cases}
ae^{-az}\quad & z\ge 0\\
0\quad & z\lt0
\end{cases}
$$$$
z=-\frac{1}{a}\times ln[1-U(0,1)]
$$<p>$$
\begin{aligned}
\mu&amp;=\frac{1}{a} \
\sigma^2 &amp;= \frac{1}{a^2}</p>
<p>\end{aligned}
$$</p>
<p>实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">a</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">=(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">blackIm</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noiseIm</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="n">blackIm</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="高斯噪声">高斯噪声
</h3>$$
\Large
p(z)=\frac{1}{\sqrt{2\pi}\sigma}\exp[{-\frac{(z-\mu)^2}{2\sigma^2}}]
$$$$
z=\mu+\sigma\times N(0,1)
$$<p>$N(0,1)$表示标准正态分布的随机数。</p>
<p>灰度值有$70%$落在$[\mu-\sigma,\mu+\sigma]$范围内。</p>
<p>实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">mu</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">sigma</span><span class="p">=</span><span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">=</span><span class="n">mu</span><span class="o">+</span><span class="n">sigma</span><span class="o">*</span><span class="nb">randn</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">blackIm</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noiseIm</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="n">blackIm</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="瑞利噪声">瑞利噪声
</h3>$$
\Large
p(z)=
\begin{cases}
\frac{2}{b}(z-a)\exp[-\frac{(z-a)^2}{b}] &z\ge a\\
0 &z\lt a
\end{cases}
$$$$
z=a+\sqrt{-b\times ln[1-U(0,1)]}
$$$$
\begin{aligned}
\mu &= a + \sqrt{\frac{\pi b}{4}} \\
\sigma^2&=\frac{b(4-\pi)}{4}
\end{aligned}
$$<p>实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">a</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">=</span><span class="mf">0.1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">=</span><span class="n">a</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)))</span><span class="o">.^</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">blackIm</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noiseIm</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="n">blackIm</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="伽马噪声">伽马噪声
</h3>$$
\Large
p(z)=
\begin{cases}
\frac{a^bz^{b-1}}{(b-1)!}e^{-az} \quad &z\gt0 \\
0 &z\lt0
\end{cases}
$$$$
z=E_1+E_2+\cdots+E_b
$$$$
\begin{aligned}
\mu &= \frac{b}{a} \\
\sigma^2 &= \frac{b}{a^2}
\end{aligned}
$$<p>
实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">a</span><span class="p">=</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">b</span><span class="p">=</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="nb">j</span><span class="p">=</span><span class="mi">1</span><span class="p">:</span><span class="n">b</span>
</span></span><span class="line"><span class="cl">	<span class="n">noise</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="nb">log</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="cl"><span class="n">blackIm</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noiseIm</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="n">blackIm</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="脉冲噪声">脉冲噪声
</h3>$$
\Large
p(z)=
\begin{cases}
P_a \quad &z=a \\
P_b &z=b \\
0 &其他
\end{cases}
$$<p>若$P_a$或$P_b$为零，则脉冲噪声称为单极脉冲；若$P_a$或$P_b$均不为零，则脉冲噪声成为双脉冲噪声或椒盐噪声。</p>
<p>通常，$a$、$b$等于所允许的最小值和最大值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">d</span><span class="p">=</span><span class="mf">0.5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">=</span><span class="nb">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">(</span><span class="n">noise</span><span class="o">&lt;</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span><span class="p">)=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noise</span><span class="p">(</span><span class="n">noise</span><span class="o">&gt;</span><span class="p">=</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;</span> <span class="n">noise</span><span class="o">&lt;</span><span class="n">d</span><span class="p">)=</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">blackIm</span><span class="p">=</span><span class="nb">zeros</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noiseIm</span><span class="p">=</span><span class="n">noise</span><span class="o">+</span><span class="n">blackIm</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="空间域滤波复原">空间域滤波复原
</h2><p>当一幅图像中存在的唯一退化因素是噪声时，其退化模型如下：</p>
$$
g(x,y)=f(x,y)+n(x,y)
$$$$
G(u,v)=F(u,v)+N(u,v)
$$<p>
可以选择空域滤波的方法来复原图像。</p>
<ul>
<li>均值滤波器、中点滤波器适合处理高斯或均匀分布等随机噪声；</li>
<li>中值滤波器适合处理椒盐噪声；</li>
<li>最大值滤波器适合处理“椒”噪声；</li>
<li>最小值滤波器适合处理“盐”噪声。</li>
</ul>
<h3 id="自适应滤波器">自适应滤波器
</h3><p>自适应滤波行为基于由$m\times n$矩形窗口$S_{xy}$定义的区域内图像的统计特征。</p>
<p>该类滤波器的响应基于：</p>
<ul>
<li>$g(x,y)$：图像$g$任意像素点的灰度值</li>
<li>$\sigma_n^2$：被污染图像$g$的方差</li>
<li>$m_L$：区域$S_{xy}$上像素点的灰度局部均值</li>
<li>$\sigma_L^2$：区域$S_{xy}$上像素点的灰度局部方差</li>
</ul>
<p>预期性能：</p>
<ul>
<li>若$\sigma_n^2=0$（零噪声），滤波器返回$g(x,y)$；</li>
<li>若$\sigma_L^2$与$\sigma_n^2$高相关，滤波器返回$g(x,y)$的近似值；</li>
<li>若$\sigma_L^2=\sigma_n^2$（局部性质和整个图像的性质相同），滤波器返回区域$S_{xy}$上像素的局部均值$m_L$。</li>
</ul>
<p>假设噪声是加性和位置无关的，$\sigma_n^2 \le \sigma_L^2$。</p>
$$
\hat{f}(x,y)=g(x,y)-\frac{\sigma_n^2}{\sigma_L^2}[g(x,y)-m_L]
$$<p>
$\sigma_n^2$是唯一事先需要知道的量。</p>
<h2 id="退化函数的估计">退化函数的估计
</h2>$$
G(u,v)=H(u,v)F(u,v)+N(u,v)
$$<h3 id="图像观察估计法">图像观察估计法
</h3><ul>
<li>
<p>寻找简单结构、受噪声影响小的子图像$g_s(x,y)$；</p>
</li>
<li>
<p>构造一个估计图像$\hat{f}_s(x,y)$，它和观察的子图像$g_s(x,y)$有相同大小和特性；</p>
</li>
<li>
$$
  H_s(u,v)=\frac{G_s(u,v)}{\hat{F}_s(u,v)}
  $$</li>
</ul>
<h3 id="试验估计法">试验估计法
</h3>$$
  H(u,v)=\frac{G(u,v)}{A}
$$<p>其中，$A$为常量，表示脉冲强度。</p>
<h3 id="模型估计法">模型估计法
</h3><h4 id="散焦模糊disk-blur">散焦模糊（Disk Blur）
</h4>$$
\large
h(x,y)=
\begin{cases}
\frac{1}{\pi R^2} \quad &x^2+y^2\le R^2 \\
0 &others
\end{cases}
$$$$
\Downarrow{DFT}
$$$$
H(u,v)=2\pi R \frac{J_1(R\sqrt{u^2+v^2})}{\sqrt{u^2+v^2}}
$$<p>其中：</p>
<ul>
<li>
<p>$R$是散焦半径；</p>
</li>
<li>
<p>$J_1(\cdot)$是一阶第一类贝塞尔（Bessel）函数；</p>
</li>
<li>
<p>$H(u,v)$是圆对称的。</p>
</li>
</ul>
<h4 id="运动模糊motion-deblur">运动模糊（Motion Deblur）
</h4>$$
H(u,v)=\frac{T}{\pi (ua+vb)}sin[\pi (ua+vb)]e^{-j\pi (ua+vb)}
$$<p>其中：</p>
<ul>
<li>$T$为采集时间长度（曝光时间）；</li>
<li>$a$、$b$分别为垂直、水平方向的运动距离。</li>
</ul>
<h4 id="大气湍流模糊">大气湍流模糊
</h4>$$
H(u,v)=e^{-k(u^2+v^2)^{5/6}}
$$<p>其中，常数$k$与湍流的性质有关，$k$越大，湍流越剧烈。</p>
<h2 id="图像复原方法逆滤波">图像复原方法——逆滤波
</h2>$$
G(u,v)=H(u,v)F(u,v)+N(u,v)
$$$$
\hat{F}(u,v)=\frac{G(u,v)}{H(u,v)}
$$<p>
没有考虑噪声的处理。</p>
<h2 id="图像复原方法维纳滤波">图像复原方法——维纳滤波
</h2>$$
\min{MSE}=\min{\frac{1}{MN}\sum_{x=0}^{M-1}\sum_{y=0}^{N-1}[\hat{f}(x,y)-f(x,y)]^2}
$$$$
H_w(u,v)=\frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+s\frac{|N(u,v)|^2}{|F(u,v)|^2}}
$$<p>
其中：</p>
<ul>
<li>$H(u,v)$为退化函数；</li>
<li>$|H(u,v)|^2$为$H(u,v)$的功率谱；</li>
<li>$s$为最小二乘约束条件的拉格朗日常数；</li>
<li>$|N(u,v)|^2$为噪声的功率谱；</li>
<li>$|F(u,v)|^2$为未退化图像的功率谱。</li>
<li>$\frac{|N(u,v)|^2}{|F(u,v)|^2}$为噪信功率比。</li>
</ul>
<p>若退化图像具有较低的噪信功率比，则维纳滤波器$H_w(u,v)$近似为逆滤波器$\frac{1}{H(u,v)}$。如果噪声为0，则维纳滤波器退化为逆滤波。</p>
$$
H_w(u,v)=\frac{1}{H(u,v)}\frac{|H(u,v)|^2}{|H(u,v)|^2+K}
$$<h1 id="形态学图像处理">形态学图像处理
</h1><h2 id="概述-1">概述
</h2><p>作用：<strong>简化图像数据</strong>，去除图像中不重要的结构，仅保持图像的基本形状特性。</p>
<p>基本思想：使用具有一定形态的<strong>结构元素</strong>去<strong>度量和提取</strong>图像中的对应<strong>形状</strong>，以达到对图像进行处理和分析的目的。</p>
<p>数学基础和所用语言：集合论</p>
<p>基本运算：<strong>膨胀</strong>、<strong>腐蚀</strong>、<strong>开启</strong>、<strong>闭合</strong>。</p>
<h2 id="集合论基础">集合论基础
</h2><h3 id="并交补差">并、交、补、差
</h3>$$
\begin{gather*}
&C=A\cup B \\
&D=A\cap B \\
&A^c=\{w|w\notin A\} \\
&A-B=\{w|w\in A, w\notin B\}=A\cap B^c
\end{gather*}
$$<h3 id="反射与平移">反射与平移
</h3><h4 id="反射">反射
</h4>$$
\hat{B}=\{w|w=-b,b\in B\}
$$$$
B:(x,y)\rightarrow \hat{B}:(-x,-y)
$$<h4 id="平移-1">平移
</h4>$$
(B)_z=\{c|c=b+z,b\in B\}
$$$$
B:(x,y)\rightarrow (B)_z:(x+z_1,y+z_2)
$$<h3 id="二值图像的逻辑运算">二值图像的逻辑运算
</h3>$$
\begin{gather*}
NOT(A) \\
(A) AND (B) \\
(A)OR(B) \\
(A)XOR(B)
\end{gather*}
$$<h2 id="二值图像形态学处理">二值图像形态学处理
</h2><p>设$A$：像素集合，$B$：结构元素（成员是感兴趣目标的像素的集合），处理过程是用$B$对$A$进行操作。</p>
<p>通过让$B$在$A$上平移，以便$B$的<strong>原点</strong>访问$A$的每一个像素，以此得到一个新的像素集合。</p>
<p>结构元素的<strong>原点</strong>是形态学运算的<strong>参考点</strong>。</p>
<p><em>原点可以包含在结构元素中，也可以不包含在结构元素中。</em></p>
$$
\begin{bmatrix}
& \cdot &  \\
\cdot & \bullet & \cdot \\
 & \cdot &  \\
\end{bmatrix}
\quad
\begin{bmatrix}
\cdot & \cdot & \cdot \\
\cdot & \bullet & \cdot \\
\cdot & \cdot & \cdot \\
\end{bmatrix}
\quad
\begin{bmatrix}
\cdot \\
\cdot \\
\bullet \\
\cdot \\
\cdot 
\end{bmatrix}
\quad
\begin{bmatrix}
& & & \cdot & & & \\
 &  & \cdot & \cdot & \cdot &  & \\
 & \cdot & \cdot & \cdot & \cdot & \cdot &   \\
\cdot & \cdot & \cdot & \bullet & \cdot & \cdot & \cdot \\
 & \cdot & \cdot & \cdot & \cdot & \cdot &   \\
 &  & \cdot & \cdot & \cdot &  & \\
& & & \cdot & & & \\
\end{bmatrix}
$$<h2 id="膨胀和腐蚀">膨胀和腐蚀
</h2><h3 id="膨胀">膨胀
</h3><p>效果：扩大图像中的物体。</p>
$$
A\oplus B=\{z|(\hat{B})_z\cap A \ne \emptyset\}
$$$$
A\oplus B = \{z|[(\hat{B})_z\cap A]\subseteq A \}
$$<p>
即$A$被$B$膨胀的结果是满足上式的所有位移$z$的点（前景像素点）的集合。</p>
<p>膨胀应用实例：桥接裂缝</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">A</span><span class="p">=</span><span class="n">imread</span><span class="p">(</span>&#34;<span class="n">broken_text</span><span class="p">.</span><span class="n">tif</span>&#34;<span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="p">=[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">;</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">;</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="p">=</span><span class="n">imdilate</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中结构元素$B:\begin{bmatrix}
0 &amp; 1 &amp; 0 \
1 &amp; 1 &amp; 1 \
0 &amp; 1 &amp; 0
\end{bmatrix}$</p>
<h3 id="腐蚀">腐蚀
</h3><p>效果：缩小图像中的物体。</p>
$$
A \ominus B = \{z|(B)_z \subseteq A\}
$$<p>
即，将结构元素$B$相对于集合$A$进行平移，只要平移后的结构元素都包含在集合$A$中，则这些位移$z$的点的集合（前景像素点）为腐蚀结果。
如果结构元素取$\begin{bmatrix}
1 &amp; 1 &amp; 1 \
1 &amp; 1 &amp; 1 \
1 &amp; 1 &amp; 1
\end{bmatrix}$，腐蚀将使物体的边界沿周边减少一个像素。</p>
<p>腐蚀可以去除<strong>小于结构元素</strong>的物体。</p>
<p>腐蚀应用实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">A</span><span class="p">=</span><span class="n">imread</span><span class="p">(</span><span class="s">&#39;wirebond.tif&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="p">=</span><span class="n">strel</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="mi">11</span><span class="p">);</span> <span class="c">%边长为11的方形结构元素</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="p">=</span><span class="n">imerode</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="开启和闭合">开启和闭合
</h2><h3 id="开启">开启
</h3>$$
A \circ B=(A\ominus B)\oplus B
$$<p>
即先用$B$对$A$腐蚀，然后用$B$对腐蚀结果进行膨胀。</p>
<p>性质：</p>
<ul>
<li>$A\circ B$是$A$的子集</li>
<li>若$C \subseteq D$，则$C\circ B\subseteq D\circ B$</li>
<li>$(A\circ B)\circ B=A \circ B$</li>
</ul>
<h3 id="闭合">闭合
</h3>$$
A\bullet B=(A\oplus B)\ominus B
$$<p>
即先用$B$对$A$膨胀，然后用$B$对腐蚀结果进行腐蚀。</p>
<p>性质：</p>
<ul>
<li>$A\bullet B$是$A$的子集</li>
<li>若$C \subseteq D$，则$C\bullet B\subseteq D\bullet B$</li>
<li>$(A\bullet B)\bullet B=A \bullet B$</li>
</ul>
<h3 id="实例matlab">实例（MATLAB）
</h3><h4 id="实例1">实例1
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">A</span><span class="p">=</span><span class="n">imread</span><span class="p">(</span><span class="s">&#39;shapes.tif&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="p">=</span><span class="n">strel</span><span class="p">(</span><span class="s">&#39;square&#39;</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">result_open</span><span class="p">=</span><span class="n">imopen</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">result_close</span><span class="p">=</span><span class="n">imclose</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">result_open_close</span><span class="p">(</span><span class="n">result_open</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="实例2去除指纹图像上的杂散点">实例2（去除指纹图像上的杂散点）
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A=imread(&#39;noisy-fingerprint.tif&#39;);
</span></span><span class="line"><span class="cl">B=strel(&#39;square&#39;,3);
</span></span><span class="line"><span class="cl">result_open=imopen(A,B);
</span></span><span class="line"><span class="cl">result_open_close=imclose(result_open,B);
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="形态学的主要应用">形态学的主要应用
</h2><h3 id="边界提取">边界提取
</h3>$$
b(A)=A-(A\ominus B)
$$<p>
其中，$B$是适当的结构元素。</p>
<p>边界提取实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">A=imread(&#39;people.jpg&#39;);
</span></span><span class="line"><span class="cl">B=strel(&#39;square&#39;,3);
</span></span><span class="line"><span class="cl">result=A-imerode(A,B);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="孔洞填充">孔洞填充
</h3><p>孔洞：被<strong>前景像素</strong>连成的边框所包围的<strong>背景区域</strong>。</p>
<ul>
<li>
<p>令$A$表示一个集合：其元素是$8$连通的边界，且每个边界包围一个孔洞；</p>
</li>
<li>
<p>令$X_0$表示一个与包含$A$的相同大小的阵列，其初始状态为：</p>
<ul>
<li>包含每个孔洞中的一个指定位置处的前景像素点；</li>
<li>除上述的前景像素点外，其余元素均为背景像素点。</li>
</ul>
</li>
<li>
$$
  X_k=(X_{k-1}\oplus B)\cap A^c\quad k=1,2,3,\cdots
  $$<ul>
<li>其中，$B$是对称结构元素，$B=\begin{bmatrix}0 &amp; 1 &amp; 0 \ 1 &amp; 1 &amp; 1 \ 0 &amp; 1 &amp; 0\end{bmatrix}$；</li>
<li>若$X_k=X_{k-1}$，则算法在迭代的第$k$步结束；</li>
<li>集合$X_k$包含所有被填充的孔洞，$X_k$和$A$的并集则包含被填充的孔洞及其边界。</li>
</ul>
</li>
</ul>
<p>每一步运算中，膨胀结果与$A^c$的交集操作实现了将膨胀结果限制在感兴趣区域内，即条件膨胀。</p>
<p><em>B对图像X的膨胀是B对X的<strong>前景元素</strong>的膨胀。</em></p>
<h1 id="图像缩放">图像缩放
</h1><h2 id="图像缩放的变换公式">图像缩放的变换公式
</h2>$$
\begin{aligned}
x&=c_xx_0 \\
y&=c_yy_0
\end{aligned}
$$$$
\begin{bmatrix}
x & y & 1
\end{bmatrix}=
\begin{bmatrix}
x_0 & y_0 & 1
\end{bmatrix}
\begin{bmatrix}
c_x & 0 & 0\\
0 & c_y & 0\\
0 & 0 & 1
\end{bmatrix}=
\begin{bmatrix}
c_xx_0 & c_yy_0 & 1
\end{bmatrix}
$$<h2 id="图像的缩小">图像的缩小
</h2><h3 id="图像缩小的实现方法">图像缩小的实现方法
</h3><p>一个简单方法是等间隔地选取样本（重采样）。</p>
$$
\begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 2 & 0 & 3 \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 4 & 0 & 5 & 0 & 6  \\
0 & 0 & 0 & 0 & 0 & 0 \\
0 & 7 & 0 & 8 & 0 & 9
\end{bmatrix}_{6\times 6}
\longrightarrow
\begin{bmatrix}
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9
\end{bmatrix}_{3\times 3}
$$<p>
<strong>算法步骤</strong>：</p>
<ol>
<li>
<p>确定重采样的行和列（采样间隔）</p>
$$
   k_x=\frac{1}{c_x}\quad k_y=\frac{1}{c_y}
   $$</li>
<li>
$$
   G(x,y)=F(int(k_x\times x),int(k_y\times y))
   $$</li>
</ol>
<h2 id="图像的放大">图像的放大
</h2><h3 id="图像放大的实现方法">图像放大的实现方法
</h3>$$
\begin{bmatrix}
1 & 2\\
3 & 4
\end{bmatrix}_{2\times 2}
\longrightarrow
\begin{bmatrix}
1 & 1 & 1 & 2 & 2 & 2 \\
1 & 1 & 1 & 2 & 2 & 2 \\
1 & 1 & 1 & 2 & 2 & 2 \\
3 & 3 & 3 & 4 & 4 & 4 \\
3 & 3 & 3 & 4 & 4 & 4 \\
3 & 3 & 3 & 4 & 4 & 4 \\
\end{bmatrix}_{6\times 6}
$$<p>
问题：容易出现马赛克效应。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>
<p>计算放大后图像的大小</p>
<p>$M\times N \rightarrow c_xM\times C_yN$</p>
</li>
<li>
$$
   G(x,y)=F(\frac{x}{c_x},\frac{y}{c_y})
   $$</li>
</ol>
$$
\begin{bmatrix}
11 & 12 & 13 \\
21 & 22 & 23 \\
31 & 32 & 33
\end{bmatrix}_{3\times 3}
\longrightarrow
\begin{bmatrix}
11 & ? & 12 & ? & 13 & ? \\
21 & ? & 22 & ? & 23 & ?\\
31 & ? & 32 & ? & 33 & ?
\end{bmatrix}_{3\times 6}
$$$$
\begin{aligned}
G(0,0)=F(0,0) \quad G(0,1)=F(0,0.5)=?\\
G(1,0)=F(1,0) \quad G(1,1)=F(1,0.5)=?\\
G(2,0)=F(2,0) \quad G(2,1)=F(2,0.5)=?
\end{aligned}
$$<h3 id="最近邻插值">最近邻插值
</h3><p>将放大后未知的像素点坐标换算到原始图像，与原始图像上邻近的$4$个像素点比较，最靠近邻近点的像素值即为该未知像素点的像素值。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>$(u,v)(G)\rightarrow(x+\Delta{x},y+\Delta{y})$；</li>
<li>计算$(x+\Delta{x},y+\Delta{y})$与$(x,y)、(x,y+1)、(x+1,y)、(x+1,y+1)$之间的距离，取距离最短的点的像素值作为$(u,v)$的像素值。</li>
</ol>
<h3 id="双线性插值">双线性插值
</h3><p>将放大后未知的像素点坐标换算到原始图像，计算原始图像上$4$个邻近像素点$A、B、C、D$对$P$点的影响，$P$点灰度值由$4$个邻近点灰度值加权求和得到（权值可以用距离进行度量）。</p>
<p><strong>算法步骤</strong>：</p>
<ul>
<li>
$$
  (x,y)、(x,y+1)、(x+1,y)、(x+1,y+1)
  $$</li>
<li>
<p>由$A、B$两点插值计算出$e$点的灰度值的$F(x,y+\Delta{y})$；</p>
</li>
</ul>
$$
\begin{aligned}
F(x,y+\Delta{y})&=\frac{\sqrt{(x-x)^2+((y+1)-(y+\Delta{y}))^2}}{\sqrt{(x-x)^2+((y+1)-y)^2}}F(x,y)\\
&\quad\ +\frac{\sqrt{(x-x)^2+((y+\Delta{y})-y)^2}}{\sqrt{(x-x)^2+((y+1)-y)^2}}F(x,y+1) \\
&= (1-\Delta{y})\times F(x,y)+\Delta{y}\times F(x,y+1)
\end{aligned}
$$$$
\begin{bmatrix}
B(x,y+1) & \cdot & \cdot \\
e(x,y+\Delta{y}) & \cdot & \cdot\\
A(x,y) & \cdot & \cdot
\end{bmatrix}
$$<ul>
<li>由$C、D$两点插值计算出$f$点的灰度值$F(x+1,y+\Delta{y})$；</li>
</ul>
$$
\begin{aligned}
F(x+1,y+\Delta{y})&=\frac{\sqrt{((x+1)-(x+1))^2+((y+1)-(y+\Delta{y}))^2}}{\sqrt{((x+1)-(x+1))^2+((y+1)-y)^2}}F(x+1,y)\\
&\quad\ +\frac{\sqrt{((x+1)-(x+1))^2+((y+\Delta{y})-y)^2}}{\sqrt{((x+1)-(x+1))^2+((y+1)-y)^2}}F(x+1,y+1) \\
&= (1-\Delta{y})\times F(x+1,y)+\Delta{y}\times F(x+1,y+1)
\end{aligned}
$$$$
\begin{bmatrix}
\cdot & \cdot & D(x+1,y+1) \\
\cdot & \cdot & f(x+1,y+\Delta{y})\\
\cdot & \cdot & C(x+1,y)
\end{bmatrix}
$$<ul>
<li>由$e、f$两点插值计算出$P$点的灰度值$F(x+\Delta{x},y+\Delta{y})$。</li>
</ul>
$$
\begin{aligned}
F(x+\Delta{x},y+\Delta{y})&=\frac{\sqrt{((x+1)-(x+\Delta{x}))^2+((y+\Delta{y})-(y+\Delta{y}))^2}}{\sqrt{((x+1)-x)^2+((y+\Delta{y})-(y+\Delta{y}))^2}}F(x,y+\Delta{y})\\
&\quad\ +\frac{\sqrt{((x+\Delta{x})-x)^2+((y+\Delta{y})-(y+\Delta{y}))^2}}{\sqrt{((x+1)-x)^2+((y+\Delta{y})-(y+\Delta{y}))^2}}F(x+1,y+\Delta{y}) \\
&= (1-\Delta{x})\times F(x,y+\Delta{y})+\Delta{x}\times F(x+1,y+\Delta{y})
\end{aligned}
$$$$
\begin{bmatrix}
\cdot & \cdot & \cdot \\
e(x,y+\Delta{y}) & P(x+\Delta{x},y+\Delta{y}) & f(x+1,y+\Delta{y})\\
\cdot & \cdot & \cdot
\end{bmatrix}
$$$$
\begin{bmatrix}
11 & 12 & 13 \\
21 & 22 & 23 \\
31 & 32 & 33
\end{bmatrix}_{3\times 3}
\longrightarrow
\begin{bmatrix}
? & ? & ? & ? & ? & ? \\
? & ? & ? & ? & ? & ?\\
? & ? & ? & ? & ? & ?
\end{bmatrix}_{3\times 6}
$$$$
\begin{aligned}
X&=
\begin{bmatrix}
0 & 1 & 2
\end{bmatrix}
\\
Y&=
\begin{bmatrix}
0 & 1 & 2 & 3 & 4 & 5
\end{bmatrix}
\end{aligned}
$$$$
\begin{aligned}
X&=
\begin{bmatrix}
0 & 1 & 2
\end{bmatrix}
\\
Y&=
\begin{bmatrix}
0 & 0.5 & 1 & 1.5 & 2 & 2.5
\end{bmatrix}
\end{aligned}
$$$$
\begin{bmatrix}
11 & ? & 12 & ? & 13 & ? \\
21 & ? & 22 & ? & 23 & ?\\
31 & ? & 32 & ? & 33 & ?
\end{bmatrix}_{3\times 6}
$$$$
\begin{bmatrix}
F(0,0) & F(0,1) \\
F(1,0) & F(1,1)
\end{bmatrix}
$$<p>
$\cdots\cdots$</p>
<h3 id="双三次插值">双三次插值
</h3><p><strong>算法原理</strong>：</p>
<ul>
<li>
<p>未知像素点$P(u,v)(G)\rightarrow$ 原始图像空间$(x,y)$；</p>
</li>
<li>
<p>确定原始图像上的$16$个邻近像素点；</p>
</li>
<li>
<p>采用下式计算$P$点的灰度值$F(x,y)$：</p>
</li>
</ul>
$$
F(x,y)=\sum_{i=0}^3\sum_{j=0}^{3}a_{ij}x^iy^j
$$<p>其中，$16$个未知系数$a_{ij}$可由原始图像$(x,y)$处的$16$个邻近像素所确定的方程组进行求解。</p>
<p><strong>算法步骤</strong>：</p>
<ol>
<li>
$$
   \begin{bmatrix}
   \cdot &  & \cdot &  & \cdot &  & \cdot \\
   & & & & & & \\
   \cdot &  & \cdot &  & \cdot &  & \cdot \\
   & & & \bullet& & & \\
   \cdot &  & \cdot &  & \cdot &  & \cdot \\
   & & & & & & \\
   \cdot &  & \cdot &  & \cdot &  & \cdot \\
   \end{bmatrix}
   $$</li>
<li>
$$
   \begin{bmatrix}
   \cdot &  & \cdot & A\cdot & \cdot &  & \cdot \\
   & & & & & & \\
   \cdot &  & \cdot & B\cdot & \cdot &  & \cdot \\
   & & & \bullet& & & \\
   \cdot &  & \cdot & C\cdot & \cdot &  & \cdot \\
   & & & & & & \\
   \cdot &  & \cdot & D\cdot & \cdot &  & \cdot 
   \end{bmatrix}
   $$$$
   F(x,y)=\sum_{j=0}^{3}a_jy^j
   $$</li>
<li>
$$
   \begin{bmatrix}
   \cdot &  & \cdot & A\cdot & \cdot &  & \cdot \\
   & & & & & & \\
   \cdot &  & \cdot & B\cdot & \cdot &  & \cdot \\
   & & & P\bullet& & & \\
   \cdot &  & \cdot & C\cdot & \cdot &  & \cdot \\
   & & & & & & \\
   \cdot &  & \cdot & D\cdot & \cdot &  & \cdot 
   \end{bmatrix}
   $$$$
   F(x,y)=\sum_{i=0}^{3}b_ix^i
   $$</li>
</ol>
<h1 id="图像边缘检测">图像边缘检测
</h1><h2 id="概述-2">概述
</h2><p>物体边界、表面方向的改变、不同的颜色、光照明暗的变化&hellip;</p>
<p>图像边缘是一组相连的像素集合，这些像素位于两个不同区域的边界上。边缘检测是一种典型的图像预处理过程。</p>
<h3 id="图像的边缘模型">图像的边缘模型
</h3><ol>
<li>
<p>台阶边缘</p>
$$
   \begin{bmatrix}
   0 & 0 & 0 & 3 & 3 & 3
   \end{bmatrix}
   $$</li>
<li>
<p>斜坡边缘</p>
$$
   \begin{bmatrix}
   0 & 0 & 0 & 1 & 2 & 3 & 3 & 3
   \end{bmatrix}
   $$</li>
<li>
<p>屋顶边缘</p>
$$
   \begin{bmatrix}
   0 & 0 & 1 & 3 & 1 & 0 & 0
   \end{bmatrix}
   $$</li>
</ol>
<h3 id="无噪图像的导数与边缘的关系">无噪图像的导数与边缘的关系
</h3>$$
\begin{bmatrix}
f & &0 & 0 & 1 & 2 & 3 & 3 & 3 \\
f' & &0 & 0 & 1 & 1 & 1 & 0 & 0 \\
f'' & &0 & 0 & 1 & 0 & -1 & 0 & 0
\end{bmatrix}
$$<ul>
<li>
<p>一阶导数的幅值可检测图像中某个点处是否存在一个边缘（峰值为边缘的位置）；</p>
</li>
<li>
<p>二阶导数的符号可用于确定一个边缘像素位于该边缘偏暗的一侧还是偏亮的一侧；</p>
</li>
<li>
<p>对于图像中的每条边缘，二阶导数生成两个值，同时二阶导数的零交叉点可用于定位粗边缘的中心。</p>
</li>
</ul>
<h2 id="基本的边缘检测技术">基本的边缘检测技术
</h2><h3 id="图像梯度及其性质">图像梯度及其性质
</h3>$$
\begin{gather*}
\nabla f=
\begin{bmatrix}
g_x & g_y
\end{bmatrix}^T=
\begin{bmatrix}
\frac{\partial f}{\partial x} & \frac{\partial f}{\partial y}
\end{bmatrix}^T
\\
|\nabla f|=\sqrt{g_x^2+g_y^2}=\sqrt{(\frac{\partial f}{\partial x})^2 + (\frac{\partial f}{\partial y})^2}
\\
\alpha(x,y)=\arctan[\frac{g_y}{g_x}]
\end{gather*}
$$<p>任意点$(x,y)$处边缘的方向与该点处梯度的方向$\alpha(x,y)$正交。</p>
<h3 id="梯度算子直接差分算子">梯度算子——直接差分算子
</h3>$$
\begin{aligned}
g_x=f(x+1,y)-f(x,y) \\
g_y=f(x,y+1)-f(x,y)
\end{aligned}
$$$$
\begin{bmatrix}
\underline{-1} & 0\\
1 & 0
\end{bmatrix}
\quad
\begin{bmatrix}
\underline{-1} & 1\\
0 & 0
\end{bmatrix}
$$<p>
直接差分算子仅能检测<strong>水平、垂直方向</strong>的边缘。</p>
<h3 id="梯度算子roberts算子">梯度算子——Roberts算子
</h3>$$
\begin{aligned}
g_x=f(x+1,y+1)-f(x,y) \\
g_y=f(x+1,y)-f(x,y+1)
\end{aligned}
$$$$
\begin{bmatrix}
\underline{-1} & 0\\
0 & 1
\end{bmatrix}
\quad
\begin{bmatrix}
\underline{0} & -1\\
1 & 0
\end{bmatrix}
$$<p>
Roberts算子可用于检测<strong>对角线方向</strong>的边缘。</p>
<h3 id="梯度算子prewitt算子">梯度算子——Prewitt算子
</h3>$$
\begin{bmatrix}
-1 & -1 & -1 \\
0 & \underline{0} & 0\\
1 & 1 & 1
\end{bmatrix}
\quad
\begin{bmatrix}
-1 & 0 & 1 \\
-1 & \underline{0} & 1\\
-1 & 0 & 1
\end{bmatrix}
$$<h3 id="梯度算子sobel算子">梯度算子——Sobel算子
</h3>$$
\begin{bmatrix}
-1 & -2 & -1 \\
0 & \underline{0} & 0\\
1 & 2 & 1
\end{bmatrix}
\quad
\begin{bmatrix}
-1 & 0 & 1 \\
-2 & \underline{0} & 2\\
-1 & 0 & 1
\end{bmatrix}
$$<h3 id="梯度算子用于检测对角边缘的prewittsobel算子">梯度算子——用于检测对角边缘的Prewitt、Sobel算子
</h3><p>对上述的Prewit模板和Sobel模板作出修改，以便它们沿对角线方向有最大的响应。</p>
$$
45\degree 方向梯度
\begin{bmatrix}
0 & 1 & 1 \\
-1 & \underline{0} & 1\\
-1 & -1 & 0
\end{bmatrix}
\quad
-45\degree 方向梯度
\begin{bmatrix}
-1 & -1 & 0 \\
-1 & \underline{0} & 1\\
0 & 1 & 1
\end{bmatrix}
$$$$
45\degree 方向梯度
\begin{bmatrix}
0 & 1 & 2 \\
-1 & \underline{0} & 1\\
-2 & -1 & 0
\end{bmatrix}
\quad
-45\degree 方向梯度
\begin{bmatrix}
-2 & -1 & 0 \\
-1 & \underline{0} & 1\\
0 & 1 & 2
\end{bmatrix}
$$<p>
一些对边缘检测不必要的细节往往表现为噪声，处理方法为：对图像<strong>进行平滑处理后再进行边缘检测</strong>。</p>
<p>参考程序（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">im</span><span class="p">=</span><span class="n">im2double</span><span class="p">(</span><span class="n">imread</span><span class="p">(</span><span class="s">&#39;building.tif&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">im</span><span class="p">=</span><span class="n">filter2</span><span class="p">(</span><span class="n">fspecial</span><span class="p">(</span><span class="s">&#39;average&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">im</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">template</span><span class="p">=[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">gx</span><span class="p">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">filter2</span><span class="p">(</span><span class="n">template</span><span class="p">,</span><span class="n">im</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">gy</span><span class="p">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">filter2</span><span class="p">(</span><span class="n">template</span><span class="p">,</span><span class="n">im</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">imGrad</span><span class="p">=</span><span class="n">gx</span><span class="o">+</span><span class="n">gy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">gx</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">gy</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">imGrad</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">im</span><span class="p">=</span><span class="n">im2double</span><span class="p">(</span><span class="n">imread</span><span class="p">(</span><span class="s">&#39;building.tif&#39;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">im</span><span class="p">=</span><span class="n">filter2</span><span class="p">(</span><span class="n">fspecial</span><span class="p">(</span><span class="s">&#39;average&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="n">im</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">template45</span><span class="p">=[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span><span class="o">-</span><span class="mi">2</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">template135</span><span class="p">=[</span><span class="o">-</span><span class="mi">2</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span><span class="p">;</span><span class="o">-</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">;</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">grad45</span><span class="p">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">filter2</span><span class="p">(</span><span class="n">template45</span><span class="p">,</span><span class="n">im</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">grad135</span><span class="p">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">filter2</span><span class="p">(</span><span class="n">template135</span><span class="p">,</span><span class="n">im</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">im</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">grad45</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span><span class="n">imshow</span><span class="p">(</span><span class="n">grad135</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="先进的边缘检测技术">先进的边缘检测技术
</h2><h3 id="marr-hildreth马尔-希尔德雷斯边缘检测器">Marr-Hildreth（马尔-希尔德雷斯）边缘检测器
</h3><h4 id="基于二阶微分导数的边缘检测技术拉普拉斯算子">基于二阶微分（导数）的边缘检测技术——拉普拉斯算子
</h4>$$
\nabla^2f=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2}
$$$$
\begin{aligned}
\frac{\partial^2f}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y) \\
\frac{\partial^2f}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y)
\end{aligned}
$$$$
\begin{bmatrix}
0 & -1 & 0\\
-1 & \underline{4} & -1\\
0 & -1 & 0
\end{bmatrix}
$$<ul>
<li>
<p>优点：</p>
<ul>
<li>
$$
    \begin{bmatrix}
    f'' & & 0 & 0 & -1 & 1 & 0 & 0
    \end{bmatrix}
    $$<p>
<em>连接$-1$和$1$，与轴线相交的点即为零交叉点。</em></p>
</li>
<li>
<p>可以确定一个像素是在边缘暗的一边还是亮的一边。</p>
</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>对噪声具有敏感性；</li>
<li>幅值产生双边缘；</li>
<li>不能检测边缘的方向。</li>
</ul>
</li>
</ul>
<h4 id="marr-hildreth边缘检测器的提出及实现">Marr-Hildreth边缘检测器的提出及实现
</h4>$$
g(x,y)=[\nabla^2G(x,y)]*f(x,y)
$$$$
g(x,y)=\nabla^2[G(x,y)*f(x,y)]
$$<p>
即，先使用一个高斯平滑滤波器平滑图像，然后对该结果执行拉普拉斯变换，故Marr-Hildreth边缘检测算法<strong>实现步骤</strong>如下：</p>
<ol>
<li>使用高斯滤波器对输入图像进行平滑滤波；</li>
<li>计算由第一步骤得到的图像的拉普拉斯变换；</li>
<li>寻找第二步骤所的图像的零交叉（由此得到的边缘为一个像素宽）。</li>
</ol>
<p>满足上述要求的算子是$\nabla^2G$（高斯拉普拉斯算子，简称LoG算子），其中：</p>
<ol>
<li>
$$
   \frac{\partial^2}{\partial x^2}+\frac{\partial^2}{\partial y^2}
   $$</li>
<li>
$$
   G(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}}
   $$</li>
</ol>
$$
\begin{aligned}
\nabla^2G(x,y)&=\frac{\partial^2G(x,y)}{\partial x^2}+\frac{\partial^2G(x,y)}{\partial y^2}\\
&=\frac{\partial}{\partial x}[\frac{-x}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}]+\frac{\partial}{\partial y}[\frac{-y}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}] \\
&=[\frac{x^2}{\sigma^4}-\frac{1}{\sigma^2}]e^{-\frac{x^2+y^2}{2\sigma^2}}+[\frac{y^2}{\sigma^4}-\frac{1}{\sigma^2}]e^{-\frac{x^2+y^2}{2\sigma^2}}\\
&=\frac{x^2+y^2-2\sigma^2}{\sigma^4}e^{-\frac{x^2+y^2}{2\sigma^2}}
\end{aligned}
$$$$
\begin{bmatrix}
0 & 0 & -1 & 0 & 0 \\
0 & -1 & -2 & -1 & 0 \\
-1 & -2 & 16 & -2 & -1 \\
0 & -1 & -2 & -1 & 0 \\
0 & 0 & -1 & 0 & 0
\end{bmatrix}
$$<p>
通过该模板得到的图像来寻找零交叉点以进行图像的边缘检测。</p>
<p>实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">edge_LoG</span><span class="p">=</span><span class="n">edge</span><span class="p">(</span><span class="n">inputImage</span><span class="p">,</span><span class="s">&#39;log&#39;</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="寻找零交叉的方法">寻找零交叉的方法
</h4><p>判定图像$g(x,y)$的任意像素$p$是否为零交叉点的一种方法如下：</p>
<ol>
<li>在图像$g(x,y)$中找到一个以$p$为中心的$3\times 3$邻域；</li>
<li>$p$像素为零交叉点意味着至少有<strong>两个相对</strong>的邻域像素的符号不同，有4种要测试的情况：左/右、上/下和两个对角；</li>
<li>如果相对的两个邻域像素的符号不同，而且它们的像素值与$p$的像素值的绝对值差值超过指定的<strong>阈值</strong>。那么，$p$即为一个零交叉像素。</li>
</ol>
<p>对于阈值为$0$的零交叉检测，会产生严重的意大利通心粉效应：所有的边缘都形成闭环，使用正阈值可避免闭环边缘。</p>
<ul>
<li>优点：
<ul>
<li>零交叉点图像中的边缘比梯度边缘细；</li>
<li>抑制噪声能力和反干扰性能好。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>边缘由零交叉点构成，而零交叉点计算比较复杂。</li>
</ul>
</li>
</ul>
<h3 id="canny坎尼边缘检测器">Canny（坎尼）边缘检测器
</h3><p>坎尼边缘检测器是基于一阶微分的边缘检测方法。</p>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>用一个大小为$n\times n$的高斯滤波器平滑输入图像（<strong>$n$的取值应为大于或等于$6$倍高斯滤波器的标准差的最小奇整数</strong>）；</li>
<li>计算滤波后图像的梯度幅值和方向角度；</li>
<li>对梯度幅值执行<strong>非极大值抑制</strong>（剔除伪边缘点，保留候选边缘点）；</li>
<li>对非极大值抑制的结果使用<strong>双阈值</strong>检测边缘（从候选边缘点中选择真实边缘点）；</li>
<li>采用<strong>连接分析</strong>对双阈值边缘检测结果进行连接（得到连续完整的边缘）。</li>
</ol>
<h4 id="非极大值抑制non-maxima-suppression-nms">非极大值抑制（Non-Maxima Suppression, NMS）
</h4><p>仅保留梯度幅值图像$M(x,y)$的极大值（严格上，保留梯度方向的极大值点），以实现边缘细化。</p>
$$
\begin{bmatrix}
& & & & & & \cdot B& & & & \\
& & & & & & & \cdot C& & & \\
& & & & & \cdot A& & & & & \\
& & & & & & & & & & \\
Th-&-&-&-&-&-&-&-&-&-&- \\
& & & & & & & & & & \\
& & & & & & & & & & \\
& & & & & & & & & & \\
& & & & & & & & & & \\
& & & &\cdot & & & & \cdot& & \\
&\cdot & &\cdot & & & & & &\cdot & \\
\cdot& &\cdot & & & & & & & & \cdot\\
\end{bmatrix}
$$<p>
<strong>实现步骤</strong>：（假设仅保留梯度幅值极大值的结果为$N(x,y)$）</p>
<ol>
<li>将$N(x,y)$初始化为原始的梯度幅值图像$M(x,y)$；</li>
<li>对于每个点$N(x,y)$，在梯度方向和反梯度方向各找$n$个像素点，若$N(x,y)$不是这些点中的最大点，则将$N(x,y)$置零，否则保持$N(x,y)$不变。</li>
</ol>
<h4 id="对nms结果使用双阈值检测边缘">对NMS结果使用双阈值检测边缘
</h4><p><strong>检测过程</strong>：</p>
<ol>
<li>指定两个阈值$T_H、T_L$：$T_H\gt T_L$（建议高阈值与低阈值比率为$2:1$或$3:1$）；</li>
<li>使用高阈值$T_H$检测边缘，得到高阈值边缘图$E_H(x,y)$（边缘点少但可靠）；</li>
<li>使用低阈值$T_L$检测边缘，得到低阈值边缘图$E_L(x,y)$（边缘点多但错误检测率高）。</li>
</ol>
<h4 id="对双阈值边缘检测结果进行边缘连接">对双阈值边缘检测结果进行边缘连接
</h4><p><strong>连接过程</strong>：</p>
<ol>
<li>将高阈值边缘图$E_H(x,y)$中相连的边缘点输出为一副边缘图像$E(x,y)$；</li>
<li>对于$E(x,y)$中每条边，从端点出发在低阈值边缘图$E_L(x,y)$中寻找其延长的部分，直至与$E(x,y)$中另外一条边的端点相连（8连通性），否则认为$E_L(x,y)$中没有它延长的部分；</li>
<li>将$E(x,y)$作为结果输出。</li>
</ol>
<p>Canny边缘检测实例（MATLAB）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-matlab" data-lang="matlab"><span class="line"><span class="cl"><span class="n">edge_LoG</span><span class="p">=</span><span class="n">edge</span><span class="p">(</span><span class="n">inputImage</span><span class="p">,</span><span class="s">&#39;canny&#39;</span><span class="p">,[</span><span class="n">T1</span> <span class="n">T2</span><span class="p">],</span><span class="n">sigma</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">Related content</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/p/%E5%9B%BE%E5%83%8F%E8%B4%A8%E9%87%8F%E8%AF%84%E4%BB%B7/">
        
        

        <div class="article-details">
            <h2 class="article-title">图像质量评价</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2024 zn.yan
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.29.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
